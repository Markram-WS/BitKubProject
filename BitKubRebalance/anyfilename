 1/1:
import pasdas as pd
from os import listdir
from os.path import isfile, join
 1/2:
import pandas as pd
from os import listdir
from os.path import isfile, join
 1/3: os.listdir()
 1/4:
import pandas as pd
from os import listdir
from os.path import isfile, join
mypath = 'C:\Users\Xavie\anaconda3\Scripts\jupyter.exe'
 1/5:
import pandas as pd
from os import listdir
from os.path import isfile, join
mypath = 'C:\Users\Xavie\Desktop\Data'
 1/6:
import pandas as pd
from os import listdir
from os.path import isfile, join
mypath = 'C:/Users/Xavie/Desktop/Data/*.csv'
 1/7: onlyfiles = [f for f in listdir(mypath) if isfile(join(mypath, f))]
 1/8:
import pandas as pd
from os import listdir
from os.path import isfile, join
mypath = 'C:/Users/Xavie/Desktop/Data/'
 1/9: onlyfiles = [f for f in listdir(mypath) if isfile(join(mypath, f))]
1/10: onlyfiles
1/11: onlyfiles =filter(lambda x: csv in x, onlyfiles)
1/12:
onlyfiles =filter(lambda x: csv in x, onlyfiles)
onlyfiles
1/13: onlyfiles
1/14:
import pandas as pd
from os import listdir
from os.path import isfile, join
mypath = 'C:/Users/Xavie/Desktop/Data/'
1/15: onlyfiles = [f for f in listdir(mypath) if isfile(join(mypath, f))]
1/16:
onlyfiles =lambda x: csv in x, onlyfiles
onlyfiles
1/17: onlyfiles
1/18:
onlyfiles =lambda onlyfiles: csv in onlyfiles
onlyfiles
1/19:
import pandas as pd
from os import listdir
from os.path import isfile, join
mypath = 'C:/Users/Xavie/Desktop/Data/'
1/20: onlyfiles = [f for f in listdir(mypath) if isfile(join(mypath, f))]
1/21: list(filter(lambda x: 'csv' in x, onlyfiles))
1/22: listdir(mypath)
1/23: isfile(join(mypath, 1)
1/24: isfile(join(mypath, 1))
1/25: join(mypath, 1)
1/26: [f for f in listdir(mypath) print(f)]
1/27:
import pandas as pd
from os import listdir
from os.path import isfile, join
mypath = 'C:/Users/Xavie/Desktop/Data/'
1/28: [f for f in listdir(mypath) print(f)]
1/29: [f for f in listdir(mypath)]
1/30: for f in listdir(mypath)
1/31:
for f in listdir(mypath):
    print(f)
1/32: [f for f in listdir(mypath)]
1/33: a=[f for f in listdir(mypath)]
1/34: a
1/35: a[]
1/36: a[0
1/37: a[0]
1/38:
files=[f for f in listdir(mypath) if 'csv' in f]
files
1/39: files=[f for f in listdir(mypath) if 'csv' in f]
1/40: files=[f for f in listdir(mypath) if 'csv' in f]
1/41: pandas.read_csv(files[0]
1/42: pandas.read_csv(files[0])
1/43: pdread_csv(files[0])
1/44: pd.read_csv(files[0])
1/45: pd.read_csv(files[0]['Date']['Close'])
1/46: pd.read_csv(files[0], usecols=['Date', 'Close'])
1/47:
dataset = pd.read_csv(files[0], usecols=['Date', 'Close'])
dataset = dataset.rename(columns={'Close':files[0]})
1/48: dataset
1/49:
dataset = pd.read_csv(files[0], usecols=['Date', 'Close'])
dataset = dataset.rename(columns={'Close':files[0].Substring(0,5)})
1/50: files[0].strtime[0:5]
1/51: files[0]
1/52: Type(files[0])
1/53: type(files[0])
1/54:
a=files[0]
a[0:5]
1/55:
a=files[0]
a[0:6]
1/56:
file_str = files[0]
dataset = pd.read_csv(file_str, usecols=['Date', 'Close'])
dataset = dataset.rename(columns={'Close':files[0].file_str[0:5]})
1/57:
file_str = files[0]
a[0:6]
1/58:
file_str = files[0]
 files[0][0:6]
1/59:
file_str = files[0]
files[0][0:6]
1/60:
dataset = pd.read_csv(files[0], usecols=['Date', 'Close'])
symbol_name = files[0][0:5]
dataset = dataset.rename(columns={'Close':symbol_name})
1/61: dataset
1/62:
for i in range(2):
    dataset = pd.read_csv(files[0], usecols=['Date', 'Close'])
    _symbol_name = files[0][0:5]
    dataset = dataset.rename(columns={'Close':symbol_name})
    if(i == 0):
        mainDataset = dataset
    else:
        mainDataset.merge(dataset)
1/63: mainDataset
1/64:
for i in range(2):
    dataset = pd.read_csv(files[i], usecols=['Date', 'Close'])
    _symbol_name = files[0][0:5]
    dataset = dataset.rename(columns={'Close':symbol_name})
    if(i == 0):
        mainDataset = dataset
    else:
        mainDataset.merge(dataset)
1/65: mainDataset
1/66: mainDataset
1/67:
dataset = pd.read_csv(files[1], usecols=['Date', 'Close'])
_symbol_name = files[0][0:5]
dataset = dataset.rename(columns={'Close':symbol_name})
1/68:
dataset = pd.read_csv(files[1], usecols=['Date', 'Close'])
_symbol_name = files[0][0:5]
dataset = dataset.rename(columns={'Close':symbol_name})
dataset
1/69:
dataset = pd.read_csv(files[0], usecols=['Date', 'Close'])
_symbol_name = files[0][0:5]
dataset = dataset.rename(columns={'Close':symbol_name})
dataset
1/70:
dataset = pd.read_csv(files[1], usecols=['Date', 'Close'])
_symbol_name = files[0][0:5]
dataset = dataset.rename(columns={'Close':symbol_name})
dataset
1/71: files[1]
1/72:
for i in range(2):
    dataset = pd.read_csv(files[i], usecols=['Date', 'Close'])
    _symbol_name = files[i][0:5]
    dataset = dataset.rename(columns={'Close':symbol_name})
    if(i == 0):
        mainDataset = dataset
    else:
        mainDataset.merge(dataset)
1/73: mainDataset
1/74: files[1]
1/75: files[0]
1/76:
dataset = pd.read_csv(files[0], usecols=['Date', 'Close'])
_symbol_name = files[0][0:5]
dataset_0 = dataset.rename(columns={'Close':symbol_name})
dataset_0
1/77: mainDataset
1/78:
dataset = pd.read_csv(files[1], usecols=['Date', 'Close'])
_symbol_name = files[1][0:5]
dataset_1 = dataset.rename(columns={'Close':symbol_name})
dataset_1
1/79:
dataset = pd.read_csv(files[0], usecols=['Date', 'Close'])
_symbol_name = files[0][0:6]
dataset_0 = dataset.rename(columns={'Close':symbol_name})
dataset_0
1/80:
dataset = pd.read_csv(files[0], index_col=False, usecols=['Date', 'Close'])
_symbol_name = files[0][0:6]
dataset_0 = dataset.rename(columns={'Close':symbol_name})
dataset_0
1/81:
dataset = pd.read_csv(files[0], index_col=False, usecols=['Date', 'Close'])
_symbol_name = files[0][0:6]
dataset_0 = dataset.rename(columns={'Close':symbol_name})
dataset_0
1/82:
dataset = pd.read_csv(files[0], index_col=False, usecols=['Date', 'Close'])
_symbol_name = files[0][0:6]
dataset_0 = dataset.rename(columns={'Close':"symbol_name"})
dataset_0
1/83: _symbol_name = files[0][0:6]
1/84:
_symbol_name = files[0][0:6]
_symbol_name
1/85:
dataset = pd.read_csv(files[0], index_col=False, usecols=['Date', 'Close'])
_symbol_name = files[0][0:6]
dataset_0 = dataset.rename(columns={'Close':_symbol_name})
dataset_0
1/86:
dataset = pd.read_csv(files[0], index_col=False, usecols=['Date', 'Close'])
_symbol_name = files[0][0:6]
dataset_0 = dataset.rename(columns={'Close':_symbol_name})
dataset_0
1/87:
dataset = pd.read_csv(files[1], index_col=False, usecols=['Date', 'Close'])
_symbol_name = files[1][0:5]
dataset_1 = dataset.rename(columns={'Close':_symbol_name})
dataset_1
1/88:
dataset = pd.read_csv(files[1], index_col=False, usecols=['Date', 'Close'])
_symbol_name = files[1][0:6]
dataset_1 = dataset.rename(columns={'Close':_symbol_name})
dataset_1
1/89: dataset_0merge(dataset_1)
1/90:
dataset_0.merge(dataset_1)
dataset_0
1/91: dataset_0.merge(dataset_1)
1/92:
for i in range(len(files)):
    dataset = pd.read_csv(files[i], index_col=False, usecols=['Date', 'Close'])
    _symbol_name = files[i][0:6]
    dataset = dataset.rename(columns={'Close':_symbol_name})
    if(i == 0):
        datasets = dataset
    else:
        datasets=datasets.merge(dataset)
1/93: datasets
1/94: datasets.dropna()
1/95:
for i in range(len(files)):
    dataset = pd.read_csv(files[i], index_col=False, usecols=['Date', 'Close'])
    _symbol_name = files[i][0:6]
    dataset = dataset.rename(columns={'Close':_symbol_name})
    if(i == 0):
        datasets = dataset
    else:
        datasets=datasets.merge(dataset)
datasets=datasets.dropna()
1/96: datasets
1/97: datasets.count(1)
1/98: datasets.count(0)
1/99: len(datasets.count(0))
1/100: datasets.count(0)
1/101: len(datasets)
1/102: len(datasets.count(0))
1/103: datasets.count(0)
1/104: datasets[0]
1/105:
for i in range(len(files)):
    dataset = pd.read_csv(files[i], index_col=True, usecols=['Date', 'Close'])
    _symbol_name = files[i][0:6]
    dataset = dataset.rename(columns={'Close':_symbol_name})
    if(i == 0):
        datasets = dataset
    else:
        datasets=datasets.merge(dataset)
datasets=datasets.dropna()
1/106:
datasets=[]
dataset=[]
for i in range(len(files)):
    dataset = pd.read_csv(files[i], index_col=True, usecols=['Date', 'Close'])
    _symbol_name = files[i][0:6]
    dataset = dataset.rename(columns={'Close':_symbol_name})
    if(i == 0):
        datasets = dataset
    else:
        datasets=datasets.merge(dataset)
datasets=datasets.dropna()
1/107:
datasets=[]
dataset=[]
for i in range(len(files)):
    dataset = pd.read_csv(files[i], usecols=['Date', 'Close'])
    _symbol_name = files[i][0:6]
    dataset = dataset.rename(columns={'Close':_symbol_name})
    if(i == 0):
        datasets = dataset
    else:
        datasets=datasets.merge(dataset)
datasets=datasets.dropna()
1/108: datasets[0]
1/109: datasets[1]
1/110: datasets.loc[1]
1/111: datasets.loc[3]
1/112: datasets.loc[:,1]
1/113: datasets.loc[5,1]
1/114: datasets.loc[5,4]
1/115: datasets.loc[5]
1/116: datasets.loc[5][1]
1/117: datasets.loc[:][1]
1/118: datasets.loc[][1]
1/119: datasets..columns: 1
1/120: datasets.columns: 1
1/121:
a=datasets.columns: 1
a
1/122:
a=datasets.columns:1
a
1/123: datasets.columns.iloc[:, 1]
1/124: datasets.iloc[:, 1]
1/125: datasets.iloc[:, 1][0]
1/126:
for i in range(1:col_number):
    print(i)
1/127:
for i in range(1,col_number):
    print(i)
1/128:
for i=1 in range(col_number):
    print(i)
1/129:
col_number = len(datasets.count(0))
for i in range(1, col_number, 1) :
    datasets.iloc[:, 1]
1/130:
for i in range(1, col_number, 1) :
    print(i)
1/131: col_number
1/132: datasets.iloc[:, 1] - datasets.iloc[:, 2]
1/133: datasets.loc[:, 1]
1/134: datasets[1]
1/135: datasets.iloc[1]
1/136: datasets.iloc[1][1]
1/137: datasets.iloc[1][0]
1/138: datasets.iloc[1]
1/139: datasets.iloc[:,1]
1/140: datasets.iloc[1]
1/141: datasets.iloc[]
1/142: datasets.iloc[1]
1/143: datasets.iloc[3]
1/144: datasets.iloc[3][1]
1/145: datasets.iloc[3][0]
1/146: datasets.iloc[3][0][0]
1/147: datasets.iloc[3][0]
1/148: datasets.iloc[3]
1/149: datasets.iloc[:, 0]
1/150: datasets.iloc[0]
1/151: datasets.iloc[0][0
1/152: datasets.iloc[0][0]
1/153: mainDataset
1/154: mainDataset['AUDCA']
1/155: mainDataset[1]
1/156: dataset_0.head()
1/157: dataset_0.columns()
1/158:
for col in dataset_0.columns: 
    print(col)
1/159:
listCol = []
for col in datasets.columns: 
    listCol.append(col)
listCol
1/160: datasets.columns
1/161: datasets.columns[1]
1/162: datasets.columns[1]+datasets.columns[2]
1/163: datasets.columns[1]+"/"+datasets.columns[2]
1/164: datasets.columns[1]+"|"+datasets.columns[2]
1/165: calDataset = {datasets.columns[1]+"|"+datasets.columns[2]:datasets.iloc[:, 1] - datasets.iloc[:, 2] }
1/166: calDataset
1/167: calDataset = {datasets.columns[1]+"|"+datasets.columns[2] : datasets.iloc[:, 1] - datasets.iloc[:, 2] }
1/168: calDataset.iloc[:, 1]
1/169: calDataset.iloc[:, 0]
1/170: calDataset = datasets.columns[1]+"|"+datasets.columns[2] : datasets.iloc[:, 1] - datasets.iloc[:, 2]
1/171:
calDataset = pd.DataFrame(
                        {datasets.columns[1]+"|"+datasets.columns[2]: datasets.iloc[:, 1] - datasets.iloc[:, 2] })
1/172: calDataset
1/173:
calDataset = pd.DataFrame(
                        {datasets.columns[2]+"|"+datasets.columns[3]: datasets.iloc[:, 2] - datasets.iloc[:, 3] })
1/174: calDataset
1/175: datasets.iloc[:, 0]
1/176: datasets.iloc[:, 1]
1/177: datasets
1/178: calDataset = datasets['Date']
1/179: calDataset
1/180:
calDataset = pd.DataFrame({'Date': datasets['Date'] })
calDataset
1/181:
calDataset = pd.DataFrame({'Date': datasets['Date'] })
calDataset.append(pd.DataFrame({datasets.columns[2]+"|"+datasets.columns[3]: datasets.iloc[:, 2] - datasets.iloc[:, 3] }))
calDataset
1/182: pd.DataFrame({datasets.columns[2]+"|"+datasets.columns[3]: datasets.iloc[:, 2] - datasets.iloc[:, 3] })
1/183:
calDataset = pd.DataFrame({'Date': datasets['Date'] })
calDataset.append( pd.DataFrame({datasets.columns[2]+"|"+datasets.columns[3]: datasets.iloc[:, 2] - datasets.iloc[:, 3] }) )
calDataset
1/184:
calDataset = pd.DataFrame({'Date': datasets['Date'] })
calDataset=calDataset.append( pd.DataFrame({datasets.columns[2]+"|"+datasets.columns[3]: datasets.iloc[:, 2] - datasets.iloc[:, 3] }) )
calDataset
1/185:  pd.DataFrame({datasets.columns[2]+"|"+datasets.columns[3]: datasets.iloc[:, 2] - datasets.iloc[:, 3] })
 2/1:
n=5
for i in range(5):
    x = input('input here')
    a=0.5+float(x)
 2/2:
n=5
for i in range(5):
    x = input('input here ')
    a=a+float(x)
avg =a/n
print(avg)
 3/1:
import  numpy as np
import pandas as pd 
import matplotlib.pyplot as plt
import statsmodels.api as sm
 3/2: data = pd.read_csv("real_estate_price_size")
 3/3: data = pd.read_csv("real_estate_price_size")
 3/4: data = pd.read_csv("real_estate_price_size.csv")
 3/5: data
 3/6: y=data["price"]
 3/7:
data = pd.read_csv("real_estate_price_size.csv")
data.head()
 3/8:
y=data["price"]
x=data["size"]
 3/9:
y=data["price"]
x=data["size"]
3/10:
y=data["price"]
x1=data["size"]
3/11:
plt.scatter(x1, y)
plt.xlabel("size",fontsize=18)
plt.xlabel("price",fontsize=18)
plt.show
3/12:
plt.scatter(x1, y)
plt.xlabel("size",fontsize=18)
plt.ylabel("price",fontsize=18)
plt.show
3/13: x = sm.add_constant(x1)
3/14:
x = sm.add_constant(x1)
x.head()
3/15:
x = sm.add_constant(x1)
x.head()
3/16:
x = sm.add_constant(x1)
x.head()
res = sm.OLS(y, x).fit()
res.summary()
3/17:
import  numpy as np
import pandas as pd 
import matplotlib.pyplot as plt
import statsmodels.api as sm
import seaborn as sb
3/18:
import  numpy as np
import pandas as pd 
import matplotlib.pyplot as plt
import statsmodels.api as sm
import seaborn as sb
sb.set()
3/19:
plt.scatter(x1, y)
plt.xlabel("size",fontsize=18)
plt.ylabel("price",fontsize=18)
plt.show
3/20: 1.019*100000
3/21:
plt.scatter(x1, y)
yHat = 101899 plt.xlabel("size",fontsize=18)
plt.ylabel("price",fontsize=18)
plt.show
3/22:
plt.scatter(x1, y)
yHat = 101899 + 223.1787 * x1
fig = plt.plot(x1, yHat, lw=4, c='red' )
plt.xlabel("size",fontsize=18)
plt.ylabel("price",fontsize=18)
plt.show
3/23:
plt.scatter(x1, y)
yHat = 101899 + 223.1787 * x1
fig = plt.plot(x1, yHat, lw=2, c='red' )
plt.xlabel("size",fontsize=18)
plt.ylabel("price",fontsize=18)
plt.show
3/24:
plt.scatter(x1, y)
yHat = 101899 + 223.1787 * x1
fig = plt.plot(x1, yHat, lw=1, c='red' )
plt.xlabel("size",fontsize=18)
plt.ylabel("price",fontsize=18)
plt.show
3/25: 0.2750 + 0.0017 * 1850
3/26: 0.2750 + 0.00 * 1850
3/27: 0.2750 + 0.0017* 1850
3/28: 0.2750 + 0.0017 * 1850
3/29: 0.0017 * 1850
3/30: 945/1245
 4/1:
import  numpy as np
import pandas as pd 
import matplotlib.pyplot as plt
import statsmodels.api as sm
import seaborn as sb
sb.set()
 4/2:
data = pd.read_csv("real_estate_price_size_year.csv")
data.head()
 4/3:
y=data["price"]
x1=data["size"]
x2=data["year"]
 4/4:
y=data["price"]
x1=data["size", "year"]
 4/5:
y=data["price"]
x1=data[["size", "year"]]
 4/6: x1.head()
 4/7:
x = sm.add_constant(x1)
x.head()
res = sm.OLS(y, x).fit()
res.summary()
 7/1:
import  numpy as np
import pandas as pd 
import matplotlib.pyplot as plt
import statsmodels.api as sm
import seaborn as sas
sas.set()
 7/2:
data = pd.read_csv("real_estate_price_size_year_view.csv")
data.head()
 7/3: data = row.data.copy()
 7/4: data = raw.data.copy()
 7/5:
raw_data = pd.read_csv("real_estate_price_size_year_view.csv")
raw_data.head()
 7/6: data = raw_data.copy()
 7/7: data
 7/8: data['view'] = data['view'] .map({'Yes':1, 'No'0})
 7/9:  data['view']
7/10:  data['view'].map({'Yes':1, 'No'0})
7/11: data['view'] = data['view'] .map({'Sea view':1, 'No sea view'0})
7/12: data['view'] = data['view'] .map({'Sea view':1, 'No sea view':0})
7/13: data['view'].head()
7/14: data.head()
7/15:
y=data["price"]
x=data[["size",'year','view']]
7/16: x
7/17: x.head()
7/18:
x = sm.add_constant(x)
x.head()
7/19:
res = sm.OLS(y, x).fit()
res.summary()
11/1:
import  numpy as np
import pandas as pd 
import matplotlib.pyplot as plt
import statsmodels.api as sm
import seaborn as sas
sas.set()
11/2:
data = pd.read_csv("real_estate_price_size.csv")
data.head()
11/3:
import  numpy as np
import pandas as pd 
import matplotlib.pyplot as plt
import seaborn as sas
sas.set()

from sklearn.liner_model import LinearRegression
11/4:
import  numpy as np
import pandas as pd 
import matplotlib.pyplot as plt
import seaborn as sas
sas.set()

from sklearn.linear_model import LinearRegression
11/5:
x = data['size']
y = data['price']
11/6: x,shape
11/7: x.shape
11/8: x.shape
11/9: y.shape
11/10: x_matrix = x.values.reshape(100,1)
11/11:
x_matrix = x.values.reshape(100,1)
x_matrix.head()
11/12:
x_matrix = x.values.reshape(100,1)
x_matrix
11/13:
x_matrix = x.values.reshape(100,2)
x_matrix
11/14:
x_matrix = x.values.reshape(100,1)
x_matrix
11/15:
x_matrix = x.values.reshape(100,1)
x_matrix[0:5]
11/16:
reg = LinearRegression()
reg.fig(x,y)
11/17:
reg = LinearRegression()
reg.fit(x,y)
11/18:
x_mat = x.values.reshape(100,1)
x_mat[0:5]
11/19:
reg = LinearRegression()
reg.fit(x_mat,y)
11/20:
x_mat = x.values.reshape(100,1)
x_mat.shape
11/21: reg.score(x_mat,y)
11/22: reg.cof
11/23: reg.coef_
11/24: reg.intercept_
11/25: reg.predict(750)
11/26: reg.predict([750])
11/27: reg.intercept_
11/28: reg.predict(750)
11/29: x.reshape(-1, 1)
11/30: x
11/31: ans = 750
11/32:
ans = 750
ans.reshape(1, -1)
11/33:
ans = 750
ans.reshape(1, 1)
11/34:
ans = [750]
ans.reshape(1, 1)
11/35: reg.predict(np.array([750]).reshape(1, 1))
11/36: reg.predict(np.array([750]))
11/37: reg.predict(np.array([750]).reshape(1, 1))
11/38: df = pd.DataFream(data=[750],columns=['size'])
11/39: df = pd.DataFrame(data=[750],columns=['size'])
11/40: df
11/41: df['Price'] = reg.predict(np.array([750]).reshape(1, 1))
11/42: df
11/43:
plt.scatter(x,y)
yhat = reg.coef_*x_mat +reg.intercept_

fig = plt.plot(x, yhat, lw=3, c='red', label='regression line')
plt.xlabel('Size', fontsize = 20)
plt,ylabel('Price', fontsize = 20)
plt.show()
11/44:
plt.scatter(x,y)
yhat = reg.coef_*x_mat +reg.intercept_

fig = plt.plot(x, yhat, lw=3, c='red', label='regression line')
plt.xlabel('Size', fontsize = 20)
plt.ylabel('Price', fontsize = 20)
plt.show()
11/45:
plt.scatter(x,y)
yhat = reg.coef_*x_mat +reg.intercept_

fig = plt.plot(x, yhat, lw=1, c='red', label='regression line')
plt.xlabel('Size', fontsize = 20)
plt.ylabel('Price', fontsize = 20)
plt.show()
11/46:
df['Price'] = reg.predict(np.array([750]).reshape(1, 1))
df
13/1: r2 = reg.score(x,y)
13/2:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
sns.set()

from sklearn.linear_model import LinearRegression
13/3:
data = pd.read_csv('1.02. Multiple linear regression.csv')
data.head()
13/4: data.describe()
13/5:
x = data[['SAT','Rand 1,2,3']]
y = data['GPA']
13/6:
reg = LinearRegression()
reg.fit(x,y)
13/7: reg.coef_
13/8: reg.intercept_
13/9: reg.score(x,y)
13/10: x.shape
13/11:
r2 = reg.score(x,y)
n = x.shape[0]
p = x.shape[1]

adjusted_r2 = 1-(1-r2)*(n-1)/(n-p-1)
adjusted_r2
13/12: r2 = reg.score(x,y)
13/13: x
13/14: x.shape
13/15: x.head()
13/16:
r2 = reg.score(x,y)
n = x.shape[0]
p = x.shape[1]
13/17:
adj_r2 = 1-(1-r2)*(n-1) / (n-p-1)
adj_r2
14/1:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
sns.set()

from sklearn.linear_model import LinearRegression
14/2:

data = pd.read_csv( 'real_estate_price_size_year.csv')
data.head()
14/3:
data = pd.read_csv( 'real_estate_price_size_year.csv')
data.head()
14/4: data.describe()
14/5:
x = data[['size','year']]
y = data['price']
14/6:
reg = LinearRegression()
reg.fit(x,y)
14/7: x.shape
14/8:
x_mat = x.values.reshape(100,2)
x_mat.shape
14/9:
reg = LinearRegression()
reg.fit(x_mat,y)
14/10: reg.coef_
16/1: reg.intercept_
14/11: reg.intercept_
14/12: reg.coef_
14/13: reg.score(x,y)
14/14:
r2 = reg.score(x,y)
n = x.shape[0]
p = x.shape[1]

adjusted_r2 = 1-(1-r2)*(n-1)/(n-p-1)
adjusted_r2
14/15: reg.predict(np.array([750]).reshape(1, 1))
14/16: reg.predict(np.array([750,2009]).reshape(1, 1))
14/17: reg.predict(np.array([750,2009]).reshape(2, 1))
14/18: reg.predict(np.array([750,2009]).reshape(1, 2))
14/19: from sklearn.feature_selection  import feature_selection
14/20: from sklearn.feature_selection  import f_regression
14/21: f_regression(x,y)
14/22: p_val = f_regression(x,y)[1]
14/23:
p_values = f_regression(x,y)[1]
p_values
14/24:
p_values = f_regression(x,y)[1]
p_values.round(3)
14/25: summary = pd.DaraFrame(data=x.columns.values, columns=['Features'])
14/26: summary = pd.DataFrame(data=x.columns.values, columns=['Features'])
14/27:
summary = pd.DataFrame(data=x.columns.values, columns=['Features'])
summary
14/28: x.columns.values
14/29:
summary = pd.DataFrame(data=x.columns.values, columns=['Features'])
summary['coefficient'] = reg.coef_
summary['p-values'] = p_values
summary
14/30:
summary = pd.DataFrame(data=x.columns.values, columns=['Features'])
summary['coefficient'] = reg.coef_
summary['p-values'] = p_values.round(3)
summary
18/1:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
sns.set()

from sklearn.linear_model import LinearRegression
18/2:
data = pd.read_csv( 'real_estate_price_size_year.csv')
data.head()
18/3:
x = data[['size','year']]
y = data['price']
18/4:
reg = LinearRegression()
reg.fit(x_mat,y)
18/5:
x = data[['size','year']]
y = data['price']
18/6:
reg = LinearRegression()
reg.fit(x,y)
18/7:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
sns.set()

from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
18/8:
scaler.StandardScaler()
scaler.fit(x)
18/9:
scaler = StandardScaler()
scaler.fit(x)
18/10: x_scaled = scaler.transform(x)
18/11:
x_scaled = scaler.transform(x)
x_scaled
18/12:
x_scaled = scaler.transform(x)
x_scaled[0:5]
18/13:
reg = LinearRegression()
reg.fit(x_scaled,y)
18/14: reg.intercept_
18/15: reg.coef_
18/16: reg.score(x_scaled,y)
18/17:
r2 = reg.score(x_scaled,y)
n = x_scaled.shape[0]
p = x_scaled.shape[1]
18/18:

adjusted_r2 = 1-(1-r2)*(n-1)/(n-p-1)
adjusted_r2
18/19: reg.predict(np.array([750,2009]).reshape(1, 2))
18/20: from sklearn.feature_selection  import f_regression
18/21: f_regression(x,y)
18/22:
summary = pd.DataFrame(data=x.columns.values, columns=['Features'])
summary['coefficient'] = reg.coef_
summary['p-values'] = p_values.round(3)
summary
18/23: f_regression(x,y)
18/24:
p_values = f_regression(x,y)[1]
p_values.round(3)
18/25:
summary = pd.DataFrame(data=x.columns.values, columns=['Features'])
summary['coefficient'] = reg.coef_
summary['p-values'] = p_values.round(3)
summary
18/26: f_regression(x_scaled,y)
18/27:
p_values = f_regression(x_scaled,y)[1]
p_values.round(3)
21/1:
import pandas as pd
import statsmodels.api as sm
import matplotlib.pyplot as plt
import seaborn as sns
sns.set()

# this part not be needed after the latests updates of the library
from scipy import stats
stats.chisqprob = lambda chisq, df: stats.chi2.sf(chisq, df)
21/2:
raw_data = pd.read_csv('Example_bank_data.csv')
raw_data
21/3:
raw_data = pd.read_csv('Example_bank_data.csv')
raw_data.head()
21/4:
raw_data = pd.read_csv('Example-bank-data.csv')
raw_data.head()
21/5:
# We make sure to create a copy of the data before we start altering it. Note that we don't change the original data we loaded.
data = raw_data.copy()

# Removes the index column that came with the data
data = data.drop(['Unnamed: 0'], axis = 1)

# We use the map function to change any 'yes' values to 1 and 'no' values to 0. 
data['y'] = data['y'].map({'yes':1, 'no':0})
data.head()
21/6:
# Check the descriptive statistics
data.describe()
21/7:
y = data['y']
x1 = data['duration']
21/8:
x = sm.add_constant(x1)
reg_log = sm.Logit(y,x)
results_log = reg_log.fit()

# Get the regression summary
results_log.summary()
21/9:
# Create a scatter plot of x1 (Duration, no constant) and y (Subscribed)
plt.scatter(x1,y,color = 'C0')

# Don't forget to label your axes!
plt.xlabel('Duration', fontsize = 20)
plt.ylabel('Subscription', fontsize = 20)
plt.show()
24/1:
import pandas as pd
import statsmodels.api as sm
import matplotlib.pyplot as plt
import seaborn as sns
sns.set()

# this part not be needed after the latests updates of the library
from scipy import stats
stats.chisqprob = lambda chisq, df: stats.chi2.sf(chisq, df)
24/2:
data = pd.read_csv( 'Example_bank_data.csv')
data.head()
24/3:
data = pd.read_csv( 'Example-bank_data.csv')
data.head()
24/4:
data = pd.read_csv( 'Example-bank-data.csv')
data.head()
24/5:
raw_data = pd.read_csv( 'Example-bank-data.csv')
raw_data.head()
24/6: raw_data = data.copy()
24/7:
raw_data = pd.read_csv( 'Example-bank-data.csv')
raw_data.head()
24/8: data = raw_data.copy()
24/9:
data = raw_data.copy()
data.head
24/10:
data = raw_data.copy()
data.head()
24/11: data = data['Unnamed: 0'].drop
24/12:
data['y'] = data['y'].map({'yes':1,'no':0})
data.head()
24/13:

data['y'] = data['y'].map({'yes':1, 'no':0})
data.head()
24/14:
raw_data = pd.read_csv( 'Example-bank-data.csv')
raw_data.head()
24/15:
data = raw_data.copy()
data.head()
24/16:
data = data['Unnamed: 0'].drop
data.head()
24/17:
data = raw_data.copy()
data.head()
24/18:
data = data.drop(['Unnamed: 0'], axis = 1)
data.head()
24/19:
raw_data = pd.read_csv( 'Example-bank-data.csv')
raw_data.head()
24/20:
data = raw_data.copy()
data.head()
24/21:
data = data.drop(['Unnamed: 0'], axis = 1)
data['y'] = data['y'].map({'yes':1, 'no':0})
data.head()
24/22:
y = data['y']
x1=data['duration']
24/23:
x = sm.add_constant(x1)
model = sm.Logit(y,x)
res = model.fit()
24/24: res.summary()
26/1:
import pandas as pd
import statsmodels.api as sm
import matplotlib.pyplot as plt
import seaborn as sns
sns.set()

from scipy import stats
stats.chisqprob = lambda chisq, df: stats.chi2.sf(chisq, df)
26/2:
raw_data = pd.read_csv('Bank_data.csv')
raw_data
26/3:
raw_data = pd.read_csv('Bank-data.csv')
raw_data.head()
26/4:
# We make sure to create a copy of the data before we start altering it. Note that we don't change the original data we loaded.
data = raw_data.copy()

# Removes the index column thata comes with the data
data = data.drop(['Unnamed: 0'], axis = 1)

# We use the map function to change any 'yes' values to 1 and 'no'values to 0. 
data['y'] = data['y'].map({'yes':1, 'no':0})
data.head()
26/5: data.describe()
26/6:
y = data['y']
x1 = data['duration']
26/7:
x = sm.add_constant(x1)
reg_log = sm.Logit(y,x)
results_log = reg_log.fit()
26/8: results_log.summary()
27/1:
import pandas as pd 
import statsmodels.api as sm
import matplotlib.pyplot as plt
import seaborn as sns
sns.set

frm spicy import stats 
stats.chisqprob = lambda chisq, df: stats.chi2.sf(chisq,df)
27/2:
import pandas as pd 
import statsmodels.api as sm
import matplotlib.pyplot as plt
import seaborn as sns
sns.set

from spicy import stats 
stats.chisqprob = lambda chisq, df: stats.chi2.sf(chisq,df)
27/3:
import pandas as pd 
import statsmodels.api as sm
import matplotlib.pyplot as plt
import seaborn as sns
sns.set

from scipy import stats 
stats.chisqprob = lambda chisq, df: stats.chi2.sf(chisq,df)
27/4: row_data = pd.read_csv('Bank-data.csv')
27/5:
row_data = pd.read_csv('Bank-data.csv')
raw_data.head()
27/6:
row_data = pd.read_csv('Bank-data.csv')
row_data.head()
27/7:
data = data.drop(['Unnamed: 0'],axis =1)
data['y'] = data['y'].map({'yes':1,'no':0})
data.head()
27/8: data = row_data.copy()
27/9:
data = data.drop(['Unnamed: 0'],axis =1)
data['y'] = data['y'].map({'yes':1,'no':0})
data.head()
27/10:
y = data['y']
x1 = data['duration']
27/11:
x = smm.add_constant(x1)
model = sm.Logit(x,y)
res = model.fit()
27/12:
x = sm.add_constant(x1)
model = sm.Logit(x,y)
res = model.fit()
27/13:
x = sm.add_constant(x1)
model = sm.Logit(y,x)
res = model.fit()
27/14: res.summary()
28/1: import pandas as pd
28/2: raw_data = pd.read_csv('Bank-data.csv')
28/3: data = raw_data.copy()
28/4:
data = raw_data.copy()
data.head()
28/5:
data = data.drop(['Unnamed: 0'],axis=1)
data['y'] = data['y'].map({'yes':1,'no':0})
data.head()
28/6:
y = data['y'] 
x1 = data['duration']
29/1:
x = sm.add_constant(x1)
model = sm.Logit(y,x)
res = model.fit()
29/2:
import pandas as pd 
import statsmodels.api as sm
import matplotlib.pyplot as plt
import seaborn as sns
sns.set

from scipy import stats 
stats.chisqprob = lambda chisq, df: stats.chi2.sf(chisq,df)
29/3:
row_data = pd.read_csv('Bank-data.csv')
row_data.head()
29/4: data = row_data.copy()
29/5:
data = data.drop(['Unnamed: 0'],axis =1)
data['y'] = data['y'].map({'yes':1,'no':0})
data.head()
29/6:
y = data['y']
x1 = data['duration']
29/7:
x = sm.add_constant(x1)
model = sm.Logit(y,x)
res = model.fit()
29/8: results_log.summary()
29/9: res.summary()
28/7:
x = smm.add_constant(x1)
model = sm.Logit(y,x)
res = model.fit()
res.summary()
28/8:
x = sm.add_constant(x1)
model = sm.Logit(y,x)
res = model.fit()
res.summary()
28/9:
import pandas as pd
import numpy as np
import statsmodels.api as sm
import matplotlib.pyplot as plt
import seborn as sns
sns.set()
from scipy import stats
stats.chaisqprob = lambda chisq, dLstats.chi2sf(chisq, df)
28/10:
import pandas as pd
import numpy as np
import statsmodels.api as sm
import matplotlib.pyplot as plt
import seborn as sns
sns.set()
from scipy import stats
stats.chaisqprob = lambda chisq, dLstats.chi2sf(chisq, df)
28/11:
import pandas as pd
import numpy as np
import statsmodels.api as sm
import matplotlib.pyplot as plt
import seborn as sns
sns.set()
from scipy import stats
stats.chaisqprob = lambda chisq, d:stats.chi2sf(chisq, df)
28/12:
import pandas as pd
import numpy as np
import statsmodels.api as sm
import matplotlib.pyplot as plt
import seborn as sns
sns.set()
from scipy import stats
stats.chaisqprob = lambda chisq, df:stats.chi2sf(chisq, df)
28/13:
import pandas as pd
import numpy as np
import statsmodels.api as sm
import matplotlib.pyplot as plt
import seaborn as sns
sns.set()
from scipy import stats
stats.chaisqprob = lambda chisq, df:stats.chi2sf(chisq, df)
28/14: raw_data = pd.read_csv('Bank-data.csv')
28/15:
data = raw_data.copy()
data.head()
28/16:
data = data.drop(['Unnamed: 0'],axis=1)
data['y'] = data['y'].map({'yes':1,'no':0})
data.head()
28/17:
y = data['y'] 
x1 = data['duration']
28/18:
x = sm.add_constant(x1)
model = sm.Logit(y,x)
res = model.fit()
res.summary()
28/19:
# Create a scatter plot of x1 (Duration, no constant) and y (Subscribed)
plt.scatter(x1,y,color = 'C0')
# Don't forget to label your axes!
plt.xlabel('Duration', fontsize = 20)
plt.ylabel('Subscription', fontsize = 20)
plt.show()
28/20: np.exp(0.0051)
32/1:
import numpy as np
import pandas as pd
import statsmodels.api as sm
import matplotlib.pyplot as plt
import seaborn as sns
sns.set()

from scipy import stats
stats.chisqprob = lambda chisq, df: stats.chi2.sf(chisq, df)
32/2: raw_data = pd.read_csv('Bank-data.csv')
32/3:
raw_data = pd.read_csv('Bank-data.csv')
raw_data.head()
32/4:
# We make sure to create a copy of the data before we start altering it. Note that we don't change the original data we loaded.
data = raw_data.copy()
# Removes the index column thata comes with the data
data = data.drop(['Unnamed: 0'], axis = 1)
# We use the map function to change any 'yes' values to 1 and 'no'values to 0. 
data['y'] = data['y'].map({'yes':1, 'no':0})
data
32/5:
# We make sure to create a copy of the data before we start altering it. Note that we don't change the original data we loaded.
data = raw_data.copy()
# Removes the index column thata comes with the data
data = data.drop(['Unnamed: 0'], axis = 1)
# We use the map function to change any 'yes' values to 1 and 'no'values to 0. 
data['y'] = data['y'].map({'yes':1, 'no':0})
data.head()
32/6: data.describe()
32/7:
y = data['y']
x1 = data['duration']
32/8:
x = sm.add_constant(x1)
reg_log = sm.Logit(y,x)
results_log = reg_log.fit()
# Get the regression summary
results_log.summary()
32/9:
# Create a scatter plot of x1 (Duration, no constant) and y (Subscribed)
plt.scatter(x1,y,color = 'C0')
# Don't forget to label your axes!
plt.xlabel('Duration', fontsize = 20)
plt.ylabel('Subscription', fontsize = 20)
plt.show()
32/10:
estimator = ['interest_rate','march','credit','previous','duration']

X1 = data[estimator]
X1
32/11:
estimator = ['interest_rate','march','credit','previous','duration']

X1 = data[estimator]
y = data['y']
32/12:
X = sm.add_constant(X1)
reg_logit = sm.Logit(y,X)
results_logit = reg_logit.fit()
results_logit.summary2()
32/13:
estimator = ['interest_rate','march','credit','previous','duration']

X1 = data[estimator]
y = data['y']
X1.head()
32/14: results_logit
32/15: confusion_matrix(X,y,results_logit)
32/16:
def confusion_matrix(data,actual_values,model):
        
        # Confusion matrix 
        
        # Parameters
        # ----------
        # data: data frame or array
            # data is a data frame formatted in the same way as your input data (without the actual values)
            # e.g. const, var1, var2, etc. Order is very important!
        # actual_values: data frame or array
            # These are the actual values from the test_data
            # In the case of a logistic regression, it should be a single column with 0s and 1s
            
        # model: a LogitResults object
            # this is the variable where you have the fitted model 
            # e.g. results_log in this course
        # ----------
        
        #Predict the values using the Logit model
        pred_values = model.predict(data)
        # Specify the bins 
        bins=np.array([0,0.5,1])
        # Create a histogram, where if values are between 0 and 0.5 tell will be considered 0
        # if they are between 0.5 and 1, they will be considered 1
        cm = np.histogram2d(actual_values, pred_values, bins=bins)[0]
        # Calculate the accuracy
        accuracy = (cm[0,0]+cm[1,1])/cm.sum()
        # Return the confusion matrix and 
        return cm, accuracy
32/17: confusion_matrix(X,y,results_logit)
34/1:
import numpy as np
import pandas as pd
import statsmodels.api as sm
import matplotlib.pyplot as plt
import seaborn as sns
sns.set()

from scipy import stats
stats.chisqprob = lambda chisq, df: stats.chi2.sf(chisq, df)
34/2:
raw_data = pd.read_csv('Bank-data.csv')
raw_data.head()
34/3:
# We make sure to create a copy of the data before we start altering it. Note that we don't change the original data we loaded.
data = raw_data.copy()
# Removes the index column thata comes with the data
data = data.drop(['Unnamed: 0'], axis = 1)
# We use the map function to change any 'yes' values to 1 and 'no'values to 0. 
data['y'] = data['y'].map({'yes':1, 'no':0})
data.head()
34/4: data.describe()
34/5:
y = data['y']
x1 = data['duration']
34/6:
x = sm.add_constant(x1)
reg_log = sm.Logit(y,x)
results_log = reg_log.fit()
# Get the regression summary
results_log.summary()
34/7:
# Create a scatter plot of x1 (Duration, no constant) and y (Subscribed)
plt.scatter(x1,y,color = 'C0')
# Don't forget to label your axes!
plt.xlabel('Duration', fontsize = 20)
plt.ylabel('Subscription', fontsize = 20)
plt.show()
34/8:
estimator = ['interest_rate','march','credit','previous','duration']

X1 = data[estimator]
y = data['y']
X1.head()
34/9:
X = sm.add_constant(X1)
reg_logit = sm.Logit(y,X)
results_logit = reg_logit.fit()
results_logit.summary2()
34/10:
def confusion_matrix(data,actual_values,model):
        
        # Confusion matrix 
        
        # Parameters
        # ----------
        # data: data frame or array
            # data is a data frame formatted in the same way as your input data (without the actual values)
            # e.g. const, var1, var2, etc. Order is very important!
        # actual_values: data frame or array
            # These are the actual values from the test_data
            # In the case of a logistic regression, it should be a single column with 0s and 1s
            
        # model: a LogitResults object
            # this is the variable where you have the fitted model 
            # e.g. results_log in this course
        # ----------
        
        #Predict the values using the Logit model
        pred_values = model.predict(data)
        # Specify the bins 
        bins=np.array([0,0.5,1])
        # Create a histogram, where if values are between 0 and 0.5 tell will be considered 0
        # if they are between 0.5 and 1, they will be considered 1
        cm = np.histogram2d(actual_values, pred_values, bins=bins)[0]
        # Calculate the accuracy
        accuracy = (cm[0,0]+cm[1,1])/cm.sum()
        # Return the confusion matrix and 
        return cm, accuracy
34/11: confusion_matrix(X,y,results_logit)
34/12:
test_data = pd.read_csv('Bank-data.csv')
test_data.head()
34/13:
# Removes the index column thata comes with the data
test_data = test_data.drop(['Unnamed: 0'], axis = 1)
34/14:
# Coverting the outcome variable into 1s and 0s again. 
test_data['y'] = test_data['y'].map({'yes':1, 'no':0})
test_data
34/15:
y_test = data_test['y']
# We already declared a list called 'estimators' that holds all relevant estimators for our model. 
X1_test = data_test[estimators]
X_test = sm.add_constant(X1_test)
34/16:
# Coverting the outcome variable into 1s and 0s again. 
test_data['y'] = test_data['y'].map({'yes':1, 'no':0})
test_data.head()
34/17:
y_test = test_data['y']
# We already declared a list called 'estimators' that holds all relevant estimators for our model. 
X1_test = test_data[estimators]
X_test = sm.add_constant(X1_test)
34/18:
# To avoid writing them out every time, we save the names of the estimators of our model in a list. 
estimators=['interest_rate','credit','march','previous','duration']
y_test = test_data['y']
# We already declared a list called 'estimators' that holds all relevant estimators for our model. 
X1_test = test_data[estimators]
X_test = sm.add_constant(X1_test)
34/19: confusion_matrix(X_test, y_test, results_logit)
34/20:
# Compare these values to the Confusion Matrix and the accuracy of the model with the old data.
# train accuracy
confusion_matrix(X_all,y, results_logit)
34/21:
X = sm.add_constant(X1)
reg_logit = sm.Logit(y,X)
results_logit = reg_logit.fit()
results_logit.summary2()
34/22:
# Determine the Confusion Matrix and the accuracy of the model with the new data. Note that the model itself stays the same (results_logit).
# test accuracy
confusion_matrix(X_test, y_test, results_logit)
34/23:
# Compare these values to the Confusion Matrix and the accuracy of the model with the old data.
# train accuracy
confusion_matrix(X_all,y, results_logit)
34/24:
# Compare these values to the Confusion Matrix and the accuracy of the model with the old data.
# train accuracy
confusion_matrix(X,y, results_logit)
34/25:
# We have to load data our model has never seen before.
raw_data2 = pd.read_csv('Bank-data-testing.csv')
data_test = raw_data2.copy()
# Removes the index column thata comes with the data
data_test = data_test.drop(['Unnamed: 0'], axis = 1)
34/26:
# Coverting the outcome variable into 1s and 0s again. 
data_test['y'] = data_test['y'].map({'yes':1, 'no':0})
data_test.head()
34/27:
y_test = data_test['y']
# We already declared a list called 'estimators' that holds all relevant estimators for our model. 
X1_test = data_test[estimators]
X_test = sm.add_constant(X1_test)
34/28:
# Determine the Confusion Matrix and the accuracy of the model with the new data. Note that the model itself stays the same (results_logit).
# test accuracy
confusion_matrix(X_test, y_test, results_logit)
39/1:
#
#   Hello World client in Python
#   Connects REQ socket to tcp://localhost:5555
#   Sends "Hello" to server, expects "World" back
#

import zmq
39/2:
context = zmq.Context()

#  Socket to talk to server
print("Connecting to hello world server…")
socket = context.socket(zmq.REQ)
socket.connect("tcp://localhost:5555")

#  Do 10 requests, waiting each time for a response
for request in range(10):
    print("Sending request %s …" % request)
    socket.send(b"Hello")

    #  Get the reply.
    message = socket.recv()
    print("Received reply %s [ %s ]" % (request, message))
39/3:
context = zmq.Context()

#  Socket to talk to server
print("Connecting to hello world server…")
socket = context.socket(zmq.REQ)
socket.connect("tcp://localhost:5555")

#  Do 10 requests, waiting each time for a response
for request in range(3):
    print("Sending request %s …" % request)
    socket.send(b"Hello")

    #  Get the reply.
    message = socket.recv()
    print("Received reply %s [ %s ]" % (request, message))
39/4:
data = b"test"
Socket(data)
39/5:
def Socket(data):
    #  Socket to talk to server
    socket = context.socket(zmq.REQ)
    socket.connect("tcp://localhost:5555")
    #print("Connecting to server…")
    socket.send(data)
return socket.recv()
39/6:
data = b"test"
Socket(data)
39/7:
def Socket(data):
    #  Socket to talk to server
    socket = context.socket(zmq.REQ)
    socket.connect("tcp://localhost:5555")
    #print("Connecting to server…")
    socket.send(data)
    return socket.recv()
39/8:
data = b"test"
Socket(data)
39/9:
data = b"test"
Socket(data)
39/10:
data = b"test"
Socket(data)
39/11:
data = b"test"
Socket(data)
40/1:
#
#   Hello World client in Python
#   Connects REQ socket to tcp://localhost:5555
#   Sends "Hello" to server, expects "World" back
#

import zmq
context = zmq.Context()
40/2:
def Socket(data):
    #  Socket to talk to server
    socket = context.socket(zmq.REQ)
    socket.connect("tcp://localhost:5555")
    #print("Connecting to server…")
    socket.send(data)
    return socket.recv()
40/3:
data = b"test"
Socket(data)
41/1:
#
#   Hello World client in Python
#   Connects REQ socket to tcp://localhost:5555
#   Sends "Hello" to server, expects "World" back
#

import zmq
context = zmq.Context()
41/2:
def Socket(data):
    try:
        #  Socket to talk to server
        socket = context.socket(zmq.REQ)
        socket.connect("tcp://localhost:5557")
        #print("Connecting to server…")
        socket.send(data)
        return socket.recv()
    except:
        print("timeout..."))
41/3:
def Socket(data):
    try:
        #  Socket to talk to server
        socket = context.socket(zmq.REQ)
        socket.connect("tcp://localhost:5557")
        #print("Connecting to server…")
        socket.send(data)
        return socket.recv()
    except:
        print("timeout...")
41/4:
data = b"test"
Socket(data)
42/1:
import sys
import zmq

port = "5556"
if len(sys.argv) > 1:
    port =  sys.argv[1]
    int(port)
    
if len(sys.argv) > 2:
    port1 =  sys.argv[2]
    int(port1)

# Socket to talk to server
context = zmq.Context()
socket = context.socket(zmq.SUB)

print "Collecting updates from weather server..."
socket.connect ("tcp://localhost:%s" % port)

if len(sys.argv) > 2:
    socket.connect ("tcp://localhost:%s" % port1)
42/2:
import sys
import zmq

port = "5556"
if len(sys.argv) > 1:
    port =  sys.argv[1]
    int(port)
    
if len(sys.argv) > 2:
    port1 =  sys.argv[2]
    int(port1)

# Socket to talk to server
context = zmq.Context()
socket = context.socket(zmq.SUB)

print("Collecting updates from weather server...")
socket.connect ("tcp://localhost:%s" % port)

if len(sys.argv) > 2:
    socket.connect ("tcp://localhost:%s" % port1)
42/3: sys.argv
42/4: port
42/5: sys.argv
42/6:
import sys
import zmq

port = "5556"

# Socket to talk to server
context = zmq.Context()
socket = context.socket(zmq.SUB)

print("Collecting updates from weather server...")
socket.connect ("tcp://localhost:%s" % port)

if len(sys.argv) > 2:
    socket.connect ("tcp://localhost:%s" % port1)
42/7:
import sys
import zmq

port = "5556"

# Socket to talk to server
context = zmq.Context()
socket = context.socket(zmq.SUB)

print("Collecting updates from weather server...")
socket.connect ("tcp://localhost:%s" % port)
42/8:
import sys
import zmq

port = "5556"

# Socket to talk to server
context = zmq.Context()
socket = context.socket(zmq.SUB)

print("Collecting updates from weather server...")
socket.connect ("tcp://localhost:%s" % port)
socket.recv()
43/1:
import sys
import zmq

port = "5556"

# Socket to talk to server
context = zmq.Context()
socket = context.socket(zmq.SUB)

print("Collecting updates from weather server...")
socket.connect ("tcp://localhost:%s" % port)
socket.recv()
44/1:
import sys
import zmq

#  Socket to talk to server
context = zmq.Context()
socket = context.socket(zmq.SUB)

print "Collecting updates from weather server…"
socket.connect ("tcp://localhost:5556")

# Subscribe to zipcode, default is NYC, 10001
zip_filter = sys.argv[1] if len(sys.argv) > 1 else "10001"
socket.setsockopt(zmq.SUBSCRIBE, zip_filter)

# Process 5 updates
total_temp = 0
for update_nbr in range (5):
    string = socket.recv()
    zipcode, temperature, relhumidity = string.split()
    total_temp += int(temperature)

print "Average temperature for zipcode '%s' was %dF" % (           
      zip_filter, total_temp / update_nbr)
44/2:
import sys
import zmq

#  Socket to talk to server
context = zmq.Context()
socket = context.socket(zmq.SUB)

print "Collecting updates from weather server…"
socket.connect ("tcp://localhost:5556")

# Subscribe to zipcode, default is NYC, 10001
zip_filter = sys.argv[1] if len(sys.argv) > 1 else "10001"
socket.setsockopt(zmq.SUBSCRIBE, zip_filter)

# Process 5 updates
total_temp = 0
for update_nbr in range (5):
    string = socket.recv()
    zipcode, temperature, relhumidity = string.split()
    total_temp += int(temperature)

print( "Average temperature for zipcode '%s' was %dF" % (           
      zip_filter, total_temp / update_nbr))
44/3:
import sys
import zmq

#  Socket to talk to server
context = zmq.Context()
socket = context.socket(zmq.SUB)

print "Collecting updates from weather server…"
socket.connect ("tcp://localhost:5556")

# Subscribe to zipcode, default is NYC, 10001
zip_filter = sys.argv[1] if len(sys.argv) > 1 else "10001"
socket.setsockopt(zmq.SUBSCRIBE, zip_filter)

# Process 5 updates
total_temp = 0
for update_nbr in range (5):
    string = socket.recv()
    zipcode, temperature, relhumidity = string.split()
    total_temp += int(temperature)

print( f"Average temperature for zipcode '{zip_filter}' was {total_temp}F" )
44/4:
import sys
import zmq

#  Socket to talk to server
context = zmq.Context()
socket = context.socket(zmq.SUB)

print() "Collecting updates from weather server…")
socket.connect ("tcp://localhost:5556")

# Subscribe to zipcode, default is NYC, 10001
zip_filter = sys.argv[1] if len(sys.argv) > 1 else "10001"
socket.setsockopt(zmq.SUBSCRIBE, zip_filter)

# Process 5 updates
total_temp = 0
for update_nbr in range (5):
    string = socket.recv()
    zipcode, temperature, relhumidity = string.split()
    total_temp += int(temperature)

print(f"Average temperature for zipcode '{zip_filter}' was {total_temp}F")
44/5:
import sys
import zmq

#  Socket to talk to server
context = zmq.Context()
socket = context.socket(zmq.SUB)

print( "Collecting updates from weather server…")
socket.connect ("tcp://localhost:5556")

# Subscribe to zipcode, default is NYC, 10001
zip_filter = sys.argv[1] if len(sys.argv) > 1 else "10001"
socket.setsockopt(zmq.SUBSCRIBE, zip_filter)

# Process 5 updates
total_temp = 0
for update_nbr in range (5):
    string = socket.recv()
    zipcode, temperature, relhumidity = string.split()
    total_temp += int(temperature)

print(f"Average temperature for zipcode '{zip_filter}' was {total_temp}F")
44/6:
import sys
import zmq

#  Socket to talk to server
context = zmq.Context()
socket = context.socket(zmq.SUB)

print( "Collecting updates from weather server…")
socket.connect ("tcp://localhost:5556")

# Subscribe to zipcode, default is NYC, 10001
zip_filter = sys.argv[1] if len(sys.argv) > 1 else "10001"
print(zip_filter)
socket.setsockopt(zmq.SUBSCRIBE, zip_filter)

# Process 5 updates
total_temp = 0
for update_nbr in range (5):
    string = socket.recv()
    zipcode, temperature, relhumidity = string.split()
    total_temp += int(temperature)

print(f"Average temperature for zipcode '{zip_filter}' was {total_temp}F")
44/7:
import sys
import zmq

#  Socket to talk to server
context = zmq.Context()
socket = context.socket(zmq.SUB)

print( "Collecting updates from weather server…")
socket.connect ("tcp://localhost:5556")

# Subscribe to zipcode, default is NYC, 10001
socket.setsockopt(zmq.SUBSCRIBE, b'10001')

# Process 5 updates
total_temp = 0
for update_nbr in range (5):
    string = socket.recv()
    zipcode, temperature, relhumidity = string.split()
    total_temp += int(temperature)

print(f"Average temperature for zipcode '{zip_filter}' was {total_temp}F")
44/8:
import sys
import zmq

#  Socket to talk to server
context = zmq.Context()
socket = context.socket(zmq.SUB)

print( "Collecting updates from weather server…")
socket.connect ("tcp://localhost:5556")

# Subscribe to zipcode, default is NYC, 10001
socket.setsockopt(zmq.SUBSCRIBE, b'10001')

# Process 5 updates
total_temp = 0
for update_nbr in range (5):
    string = socket.recv()
    zipcode, temperature, relhumidity = string.split()
    total_temp += int(temperature)

print(f"Average temperature for zipcode '{10001}' was {total_temp}F")
44/9:
import sys
import zmq
while(true):
    #  Socket to talk to server
    context = zmq.Context()
    socket = context.socket(zmq.SUB)

    print( "Collecting updates from weather server…")
    socket.connect ("tcp://localhost:5556")

    # Subscribe to zipcode, default is NYC, 10001
    socket.setsockopt(zmq.SUBSCRIBE, b'10001')

    # Process 5 updates
    total_temp = 0
    for update_nbr in range (5):
        string = socket.recv()
        zipcode, temperature, relhumidity = string.split()
        total_temp += int(temperature)

    print(f"Average temperature for zipcode '{10001}' was {total_temp}F")
44/10:
import sys
import zmq
while(True):
    #  Socket to talk to server
    context = zmq.Context()
    socket = context.socket(zmq.SUB)

    print( "Collecting updates from weather server…")
    socket.connect ("tcp://localhost:5556")

    # Subscribe to zipcode, default is NYC, 10001
    socket.setsockopt(zmq.SUBSCRIBE, b'10001')

    # Process 5 updates
    total_temp = 0
    for update_nbr in range (5):
        string = socket.recv()
        zipcode, temperature, relhumidity = string.split()
        total_temp += int(temperature)

    print(f"Average temperature for zipcode '{10001}' was {total_temp}F")
44/11:
import zmq

context = zmq.Context()

#  Socket to talk to server
print("Connecting to hello world server…")
socket = context.socket(zmq.REQ)
socket.connect("tcp://localhost:5555")

#  Do 10 requests, waiting each time for a response
for request in range(3):
    print("Sending request %s …" % request)
    socket.send(b"Hello")

    #  Get the reply.
    message = socket.recv()
    print("Received reply %s [ %s ]" % (request, message))
44/12:
import zmq

context = zmq.Context()

#  Socket to talk to server
print("Connecting to hello world server…")
socket = context.socket(zmq.REQ)
socket.connect("tcp://localhost:5555")

#  Do 10 requests, waiting each time for a response
for request in range(3):
    print("Sending request %s …" % request)
    socket.send(b"Hello")

    #  Get the reply.
    message = socket.recv()
    print("Received reply %s [ %s ]" % (request, message))
44/13:
import zmq

context = zmq.Context()

#  Socket to talk to server
print("Connecting to hello world server…")
socket = context.socket(zmq.REQ)
socket.connect("tcp://localhost:5557")

#  Do 10 requests, waiting each time for a response
for request in range(3):
    print("Sending request %s …" % request)
    socket.send(b"Hello")

    #  Get the reply.
    message = socket.recv()
    print("Received reply %s [ %s ]" % (request, message))
45/1:
import zmq
context = zmq.Context()
socket = context.socket(zmq.REQ)  # this connection utilizes REQ/REP
socket.connect("tcp://localhost:5557")
socket.send(b'work')

message = socket.recv()
rint("Received reply %s [ %s ]" % (request, message))
46/1:
import zmq
context = zmq.Context()
socket = context.socket(zmq.REQ)  # this connection utilizes REQ/REP
socket.connect("tcp://localhost:5555")
print("Sending request %s …")
socket.send(b"work")

#  Get the reply.
message = socket.recv()
print("Received reply %s [ %s ]" % (request, message))
46/2:
import zmq
context = zmq.Context()
socket = context.socket(zmq.REQ)  # this connection utilizes REQ/REP
socket.connect("tcp://localhost:5555")
print("Sending request %s …")
socket.send(b"work")

#  Get the reply.
message = socket.recv(request)
print("Received reply %s [ %s ]" % (request, message))
46/3:
import zmq
context = zmq.Context()
socket = context.socket(zmq.REQ)  # this connection utilizes REQ/REP
socket.connect("tcp://localhost:5555")
print("Sending request %s …")
socket.send(b"work")

#  Get the reply.
message = socket.recv(request)
print(f"Received reply {message}]" )
46/4:
import zmq
context = zmq.Context()
socket = context.socket(zmq.REQ)  # this connection utilizes REQ/REP
socket.connect("tcp://localhost:5555")
print("Sending request %s …")
socket.send(b"work")

#  Get the reply.
message = socket.recv()
print(f"Received reply {message}]" )
46/5:
import zmq
context = zmq.Context()
socket = context.socket(zmq.REQ)  # this connection utilizes REQ/REP
socket.connect("tcp://localhost:5555")
print("Sending request %s …")
socket.send(b"work,find")

#  Get the reply.
message = socket.recv()
print(f"Received reply {message}]" )
46/6:
import zmq
context = zmq.Context()
socket = context.socket(zmq.REQ)  # this connection utilizes REQ/REP
socket.connect("tcp://localhost:5555")
socket.send(b"work,find")
print("Sending request …")

#  Get the reply.
message = socket.recv()
print(f"Received reply {message}]" )
46/7:
import zmq
context = zmq.Context()
socket = context.socket(zmq.REQ)  # this connection utilizes REQ/REP
socket.connect("tcp://localhost:5555")
socket.send(b"work,find")
print("Sending request …")

#  Get the reply.
message = socket.recv()
print(f"Received reply {message}]" )
46/8:
import zmq
context = zmq.Context()
socket = context.socket(zmq.REQ)  # this connection utilizes REQ/REP
socket.connect("tcp://localhost:5555")
socket.send(b"work,find")
print("Sending request …")

#  Get the reply.
message = socket.recv()
print(f"Received reply {message}" )
46/9:
import zmq
context = zmq.Context()
socket = context.socket(zmq.REQ)  # this connection utilizes REQ/REP
socket.connect("tcp://localhost:5555")
socket.send(b"work,find,1234")
print("Sending request …")

#  Get the reply.
message = socket.recv()
print(f"Received reply {message}" )
47/1:
import zmq
context = zmq.Context()
socket = context.socket(zmq.REQ)  # this connection utilizes REQ/REP
socket.connect("tcp://localhost:5555")
socket.send(b"s50z20,Tick")
print("Sending request …")

#  Get the reply.
message = socket.recv()
print(f"Received reply {message}" )
48/1:
import zmq
context = zmq.Context()
socket = context.socket(zmq.REQ)  # this connection utilizes REQ/REP
socket.connect("tcp://localhost:5555")
socket.send(b"s50z20,Tick,0")
print("Sending request …")

#  Get the reply.
message = socket.recv()
print(f"Received reply {message}" )
49/1:
import zmq
context = zmq.Context()
socket = context.socket(zmq.REQ)  # this connection utilizes REQ/REP
socket.connect("tcp://localhost:5555")
socket.send(b"s50z20,Tick,0")
print("Sending request …")

#  Get the reply.
message = socket.recv()
print(f"Received reply {message}" )
49/2:
import zmq
context = zmq.Context()
socket = context.socket(zmq.REQ)  # this connection utilizes REQ/REP
socket.connect("tcp://localhost:5555")
socket.send(b"s50z20,Tick,0")
print("Sending request …")

#  Get the reply.
message = socket.recv()
print(f"Received reply {message}" )
49/3:
import zmq
context = zmq.Context()
socket = context.socket(zmq.REQ)  # this connection utilizes REQ/REP
socket.connect("tcp://localhost:5555")
socket.send(b"S50Z20,Tick,0")
print("Sending request …")

#  Get the reply.
message = socket.recv()
print(f"Received reply {message}" )
49/4:
import zmq
context = zmq.Context()
socket = context.socket(zmq.REQ)  # this connection utilizes REQ/REP
socket.connect("tcp://localhost:5555")
socket.send("S50Z20,Tick,0")
print("Sending request …")

#  Get the reply.
message = socket.recv()
print(f"Received reply {message}" )
49/5:
import zmq
context = zmq.Context()
socket = context.socket(zmq.REQ)  # this connection utilizes REQ/REP
socket.connect("tcp://localhost:5555")
socket.send(b"S50Z20,Tick,0")
print("Sending request …")

#  Get the reply.
message = socket.recv()
print(f"Received reply {message}" )
49/6:
import zmq
context = zmq.Context()
socket = context.socket(zmq.REQ)  # this connection utilizes REQ/REP
socket.connect("tcp://localhost:5555")
socket.send(b"S50Z20,Tick,0")
print("Sending request …")

#  Get the reply.
message = socket.recv()
print(f"Received reply {message}" )
49/7:
import zmq
context = zmq.Context()
socket = context.socket(zmq.REQ)  # this connection utilizes REQ/REP
socket.connect("tcp://localhost:5555")
socket.send(b"S50_DUMMY,Tick")
print("Sending request …")

#  Get the reply.
message = socket.recv()
print(f"Received reply {message}" )
49/8:
while(True):
    getMT4data("S50_DUMMY,Ask")
49/9:
import zmq

def getMT4data(sendMsg):
    context = zmq.Context()
    socket = context.socket(zmq.REQ)  # this connection utilizes REQ/REP
    socket.connect("tcp://localhost:5555")
    socket.send(b"{}".format(sendMsg))
    print("Sending request …")

    #  Get the reply.
    message = socket.recv()
    print(f"Received reply {message}" )
49/10:
while(True):
    getMT4data("S50_DUMMY,Ask")
49/11:
import zmq

def getMT4data(sendMsg):
    context = zmq.Context()
    socket = context.socket(zmq.REQ)  # this connection utilizes REQ/REP
    socket.connect("tcp://localhost:5555")
    socket.send(f"{sendMsg}".encode())
    print("Sending request …")

    #  Get the reply.
    message = socket.recv()
    print(f"Received reply {message}" )
49/12:
while(True):
    getMT4data("S50_DUMMY,Ask")
49/13:
while(True):
    getMT4data("S50_DUMMY,Tick")
49/14:
import zmq
import time




def getMT4data(sendMsg):
    context = zmq.Context()
    socket = context.socket(zmq.REQ)  # this connection utilizes REQ/REP
    socket.connect("tcp://localhost:5555")
    socket.send(f"{sendMsg}".encode())
    print("Sending request …")

    #  Get the reply.
    message = socket.recv()
    print(f"Received reply {message}" )
49/15:
while(True):
    print(getMT4data("S50_DUMMY,Tick"))
    time.sleep(3)
49/16:
import zmq
import time




def getMT4data(sendMsg):
    context = zmq.Context()
    socket = context.socket(zmq.REQ)  # this connection utilizes REQ/REP
    socket.connect("tcp://localhost:5555")
    socket.send(f"{sendMsg}".encode())
    #print("Sending request …")

    return socket.recv()
49/17:
while(True):
    print(getMT4data("S50_DUMMY,Tick"))
    time.sleep(3)
49/18:
while(True):
    print(getMT4data("S50_DUMMY,Tick").text(),end="")
    time.sleep(3)
49/19:
import zmq
import time




def getMT4data(sendMsg):
    context = zmq.Context()
    socket = context.socket(zmq.REQ)  # this connection utilizes REQ/REP
    socket.connect("tcp://localhost:5555")
    socket.send(f"{sendMsg}".encode())
    #print("Sending request …")

    return socket.recv().decode('utf-8')
49/20:
while(True):
    print(getMT4data("S50_DUMMY,Tick").text(),end="")
    time.sleep(3)
50/1:
import zmq
import time


def getMT4data(sendMsg):
    context = zmq.Context()
    socket = context.socket(zmq.REQ)  # this connection utilizes REQ/REP
    socket.connect("tcp://localhost:5555")
    socket.send(f"{sendMsg}".encode())
    #print("Sending request …")

    return socket.recv()
50/2:
while(True):
    print(getMT4data("S50_DUMMY,Tick") ,end="")
          print(getMT4data("S50_DUMMY,Tick").decode() ,end="")
    time.sleep(3)
50/3:
while(True):
    print(getMT4data("S50_DUMMY,Tick") ,end="")
          print(getMT4data("S50_DUMMY,Tick").decode('utf8') ,end="")
    time.sleep(3)
50/4:
while(True):
    a = getMT4data("S50_DUMMY,Tick") 
    print(a.encode())
    time.sleep(3)
50/5:
import zmq
import time


def getMT4data(sendMsg):
    context = zmq.Context()
    socket = context.socket(zmq.REQ)  # this connection utilizes REQ/REP
    socket.connect("tcp://localhost:5555")
    socket.send(f"{sendMsg}".encode())
    #print("Sending request …")

    return socket.recv()
50/6:
while(True):
    a = getMT4data("S50_DUMMY,Tick") 
    print(a.encode())
    time.sleep(3)
50/7:
while(True):
    a = getMT4data("S50_DUMMY,Tick") 
    a.encode('ASCII') 
    time.sleep(3)
50/8:
while(True):
    a = getMT4data("S50_DUMMY,Tick") 
    a.read()
    time.sleep(3)
50/9:
while(True):
    a = getMT4data("S50_DUMMY,Tick") 
    type(a)
    time.sleep(3)
51/1:
import zmq
import time


def getMT4data(sendMsg):
    context = zmq.Context()
    socket = context.socket(zmq.REQ)  # this connection utilizes REQ/REP
    socket.connect("tcp://localhost:5555")
    socket.send(f"{sendMsg}".encode())
    #print("Sending request …")

    return socket.recv()
51/2:
while(True):
    a = getMT4data("S50_DUMMY,Tick") 
    type(a)
    time.sleep(3)
51/3:
while(True):
    a = getMT4data("S50_DUMMY,Tick") 
    type(a)
51/4:
while(True):
    print("start")
    a = getMT4data("S50_DUMMY,Tick") 
    type(a)
52/1:
import zmq
import time


def getMT4data(sendMsg):
    context = zmq.Context()
    socket = context.socket(zmq.REQ)  # this connection utilizes REQ/REP
    socket.connect("tcp://localhost:5555")
    socket.send(f"{sendMsg}".encode())
    #print("Sending request …")

    return socket.recv()
52/2:
while(True):
    print("start")
    print(getMT4data("S50_DUMMY,Tick") )
53/1:
while(True):
    data= getMT4data("S50_DUMMY,Tick") 
    print(data)
    time.sleep(5)
53/2:
import zmq
import time


def getMT4data(sendMsg):
    context = zmq.Context()
    socket = context.socket(zmq.REQ)  # this connection utilizes REQ/REP
    socket.connect("tcp://localhost:5555")
    socket.send(f"{sendMsg}".encode())
    #print("Sending request …")

    return socket.recv()
53/3:
while(True):
    data= getMT4data("S50_DUMMY,Tick") 
    print(data)
    time.sleep(5)
53/4:
while(True):
    data= getMT4data("S50_DUMMY,Tick") 
    type(data)
    time.sleep(5)
53/5:
while(True):
    data= getMT4data("S50_DUMMY,Tick") 
    print(data)
    print(data.encode())
    print("----------------------")
    time.sleep(5)
53/6:
while(True):
    data= getMT4data("S50_DUMMY,Tick") 
    print(data)
    print(data.gensalt())
    print("----------------------")
    time.sleep(5)
53/7:
while(True):
    data= getMT4data("S50_DUMMY,Tick") 
    print(data)
    print(base64.b64encode(data.read()))
    print("----------------------")
    time.sleep(5)
53/8:
import zmq
import time
import base64

def getMT4data(sendMsg):
    context = zmq.Context()
    socket = context.socket(zmq.REQ)  # this connection utilizes REQ/REP
    socket.connect("tcp://localhost:5555")
    socket.send(f"{sendMsg}".encode())
    #print("Sending request …")

    return socket.recv()
53/9:
while(True):
    data= getMT4data("S50_DUMMY,Tick") 
    print(data)
    print(base64.b64encode(data.read()))
    print("----------------------")
    time.sleep(5)
53/10:
while(True):
    data= getMT4data("S50_DUMMY,Tick") 
    data = base64.b64encode(bytes(data,'utf-8')) # to encode above text
    print(data)
    print("----------------------")
    time.sleep(5)
53/11:
while(True):
    data= getMT4data("S50_DUMMY,Tick") 
    data = base64.b64decode(data) # to encode above text
    print(data)
    print("----------------------")
    time.sleep(5)
53/12:
while(True):
    data= getMT4data("S50_DUMMY,Tick") 
    print(str(data, 'utf-8'))
    print("----------------------")
    time.sleep(5)
54/1:
import zmq
import time


def getMT4data(sendMsg):
    context = zmq.Context()
    socket = context.socket(zmq.REQ)  # this connection utilizes REQ/REP
    socket.connect("tcp://localhost:5555")
    socket.send(f"{sendMsg}".encode())
    #print("Sending request …")
    return str(socket.recv(), 'utf-8')
54/2:
for i in range(10):
    data= getMT4data(f"S50_DUMMY,Price,1m,{i}") 
    print(data)
    time.sleep(5)
print("----------------------")
54/3:
data = []
for i in range(10):
    a= getMT4data(f"S50_DUMMY,Price,1m,{i}") 
    data.append(a)
data
54/4:

data[0]
54/5:

data[0][1]
54/6:

data[0]
54/7:
data = []
for i in range(10):
    a= getMT4data(f"S50_DUMMY,Tick") 
    data.append(a)
data
54/8: data[0]
54/9:
import zmq
import time


def getMT4data(sendMsg):
    context = zmq.Context()
    socket = context.socket(zmq.REQ)  # this connection utilizes REQ/REP
    socket.connect("tcp://localhost:5555")
    socket.send(f"{sendMsg}".encode())
    #print("Sending request …")
    return str(socket.recv(), 'utf-8').split(",")
54/10:
data = []
for i in range(10):
    a= getMT4data(f"S50_DUMMY,Price,1m,{i}") 
    data.append(a)
data
54/11:

data[0]
54/12:

data[0][1]
54/13: datetime.datetime.fromtimestamp(int(data[0][1])/1000.0)
54/14:
import datetime
datetime.datetime.fromtimestamp(int(data[0][1])/1000.0)
54/15:
import datetime
datetime.datetime.fromtimestamp(float(data[0][1])/1000.0)
54/16:
import datetime
datetime.datetime.fromtimestamp(float(data[0][1]))
54/17:
data = []
for i in range(10):
    a= getMT4data(f"S50Z20,Price,1m,{i}") 
    data.append(a)
data
54/18:
import datetime
datetime.datetime.fromtimestamp(float(data[0][1]))
54/19:
import datetime
datetime.datetime.fromtimestamp(float(data[0][1]))
54/20:
import datetime
datetime.datetime.fromtimestamp(float(data[5][1]))
54/21:
import datetime
datetime.datetime.fromtimestamp(float(data[5][1]))
54/22:
import datetime
datetime.datetime.fromtimestamp(float(data[5][1])/1000)
54/23:
import datetime
datetime.datetime.fromtimestamp(float(data[5][1])
54/24:
import datetime
float(data[5][1]).strftime('%Y-%m-%d %H:%M:%S.%f')
54/25:
import datetime
datetime.float(data[5][1]).strftime('%Y-%m-%d %H:%M:%S.%f')
54/26:
import datetime
datef= float(data[5][1])
datetime.datef.strftime('%Y-%m-%d %H:%M:%S.%f')
54/27:
import datetime

date = datetime.datetime.fromtimestamp(float(data[5][1])/1000.0)
date = date.strftime('%Y-%m-%d %H:%M:%S')
54/28:
data = []
for i in range(10):
    a= getMT4data(f"S50Z20,Price,1m,{i}") 
    data.append(a)
data.head()
54/29:
data = []
for i in range(10):
    a= getMT4data(f"S50Z20,Price,1m,{i}") 
    data.append(a)
data
54/30:
import datetime

dateTime = datetime.datetime.fromtimestamp(float(data[5][1])/1000.0)
dateTime = date.strftime('%Y-%m-%d %H:%M:%S')
dateTime
54/31:
import datetime

dateTime = datetime.datetime.fromtimestamp(float(data[5][1])/1000.0)
#dateTime = date.strftime('%Y-%m-%d %H:%M:%S')
dateTime
54/32:
import datetime

dateTime = datetime.datetime.fromtimestamp(float(data[5][1]))
#dateTime = date.strftime('%Y-%m-%d %H:%M:%S')
dateTime
54/33:
import datetime

dateTime = datetime.datetime.fromtimestamp(float(data[5][1]))
dateTime = date.strftime('%Y-%m-%d %H:%M:%S')
dateTime
54/34:
import datetime

dateTime = datetime.datetime.fromtimestamp(float(data[5][1]))
dateTime
54/35:
import datetime
for i in range(10):
    dateTime = datetime.datetime.fromtimestamp(float(data[i][1]))
    print(dateTime)
54/36:
import zmq
import time


def getMT4data(sendMsg):
    context = zmq.Context()
    socket = context.socket(zmq.REQ)  # this connection utilizes REQ/REP
    socket.connect("tcp://localhost:5555")
    socket.send(f"{sendMsg}".encode())
    #print("Sending request …")
    return str(socket.recv(), 'utf-8').split(",")
54/37:
data = []
for i in range(10):
    a= getMT4data(f"S50Z20,Price,1m,{i}") 
    data.append(a)
data
54/38:
a= getMT4data(f"S50Z20,Price,1m,all") 
a
58/1:
raw_data = pd.read_csv('Bank_data.csv')
raw_data
58/2:
import numpy as np
import pandas as pd
import statsmodels.api as sm
import matplotlib.pyplot as plt
import seaborn as sns
sns.set()

from scipy import stats
stats.chisqprob = lambda chisq, df: stats.chi2.sf(chisq, df)
58/3:
raw_data = pd.read_csv('Bank_data.csv')
raw_data
58/4:
raw_data = pd.read_csv('Bank_data.csv')
raw_data
59/1:
import pandas as pd
import numpy as np
import statsmodels.api as sm
import matplotlib.pyplot as plt
import seaborn as sns
sns.set()
from scipy import stats
stats.chaisqprob = lambda chisq, df:stats.chi2sf(chisq, df)
59/2: raw_data = pd.read_csv('Bank-data.csv')
59/3:
data = raw_data.copy()
data.head()
59/4:
data = data.drop(['Unnamed: 0'],axis=1)
data['y'] = data['y'].map({'yes':1,'no':0})
data.head()
59/5:
data = data.drop(['Unnamed: 0'],axis=1)
data['y'] = data['y'].map({'yes':1,'no':0})
data.head()
59/6:
y = data['y'] 
x1 = data['duration']
59/7:
x = sm.add_constant(x1)
model = sm.Logit(y,x)
res = model.fit()
res.summary()
59/8:
# Create a scatter plot of x1 (Duration, no constant) and y (Subscribed)
plt.scatter(x1,y,color = 'C0')
# Don't forget to label your axes!
plt.xlabel('Duration', fontsize = 20)
plt.ylabel('Subscription', fontsize = 20)
plt.show()
59/9: np.exp(0.0051)
65/1:
import numpy as np
import pandas as pd
import statsmodels.api as sm
import matplotlib.pyplot as plt
import seaborn as sns
sns.set()

from scipy import stats
stats.chisqprob = lambda chisq, df: stats.chi2.sf(chisq, df)
65/2:
raw_data = pd.read_csv('Bank-data.csv')
raw_data.head()
65/3:
# We make sure to create a copy of the data before we start altering it. Note that we don't change the original data we loaded.
data = raw_data.copy()
# Removes the index column thata comes with the data
data = data.drop(['Unnamed: 0'], axis = 1)
# We use the map function to change any 'yes' values to 1 and 'no'values to 0. 
data['y'] = data['y'].map({'yes':1, 'no':0})
data.head()
65/4: data.describe()
65/5:
y = data['y']
x1 = data['duration']
65/6:
x = sm.add_constant(x1)
reg_log = sm.Logit(y,x)
results_log = reg_log.fit()
# Get the regression summary
results_log.summary()
65/7:
# Create a scatter plot of x1 (Duration, no constant) and y (Subscribed)
plt.scatter(x1,y,color = 'C0')
# Don't forget to label your axes!
plt.xlabel('Duration', fontsize = 20)
plt.ylabel('Subscription', fontsize = 20)
plt.show()
65/8:
# To avoid writing them out every time, we save the names of the estimators of our model in a list. 
estimators=['interest_rate','march','credit','previous','duration']

X1 = data[estimators]
y = data['y']
65/9:
X = sm.add_constant(X1)
reg_logit = sm.Logit(y,X)
results_logit = reg_logit.fit()
results_logit.summary2()
65/10:
def confusion_matrix(data,actual_values,model):
        
        # Confusion matrix 
        
        # Parameters
        # ----------
        # data: data frame or array
            # data is a data frame formatted in the same way as your input data (without the actual values)
            # e.g. const, var1, var2, etc. Order is very important!
        # actual_values: data frame or array
            # These are the actual values from the test_data
            # In the case of a logistic regression, it should be a single column with 0s and 1s
            
        # model: a LogitResults object
            # this is the variable where you have the fitted model 
            # e.g. results_log in this course
        # ----------
        
        #Predict the values using the Logit model
        pred_values = model.predict(data)
        # Specify the bins 
        bins=np.array([0,0.5,1])
        # Create a histogram, where if values are between 0 and 0.5 tell will be considered 0
        # if they are between 0.5 and 1, they will be considered 1
        cm = np.histogram2d(actual_values, pred_values, bins=bins)[0]
        # Calculate the accuracy
        accuracy = (cm[0,0]+cm[1,1])/cm.sum()
        # Return the confusion matrix and 
        return cm, accuracy
65/11: confusion_matrix(X,y,results_logit)
68/1:
import pandas as pd
import numpy as np
import matplot.lib.pyplot as plt
import seaborn as sns
from sklearn.cluster import KMeans
68/2:
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.cluster import KMeans
68/3: data = pd.read_csv( 'Countries.csv')
68/4: data = pd.read_csv( 'Countries-exercise.csv')
68/5:
data = pd.read_csv( 'Countries-exercise.csv')
data.head()
68/6:
# Create a scatter plot of x1 (Duration, no constant) and y (Subscribed)
plt.scatter(data['Longitude'],data['Latitude'],color = 'C0')
# Don't forget to label your axes!
plt.xlabel('Longitude', fontsize = 20)
plt.ylabel('Latitude', fontsize = 20)
plt.show()
68/7:
# Create a scatter plot of x1 (Duration, no constant) and y (Subscribed)
plt.scatter(data['Longitude'],0,color = 'C0')
# Don't forget to label your axes!
plt.xlabel('Longitude', fontsize = 20)
plt.ylabel('Latitude', fontsize = 20)
plt.show()
68/8:
# Create a scatter plot of x1 (Duration, no constant) and y (Subscribed)
plt.scatter(data['Longitude'],data['Latitude'],color = 'C0')
# Don't forget to label your axes!
plt.xlabel('Longitude', fontsize = 20)
plt.ylabel('Latitude', fontsize = 20)
plt.show()
68/9: x = data.iloc[:,1:]
68/10:
x = data.iloc[:,1:]
x.head()
68/11: kmeans = Kmeans(2)
68/12: kmeans = KMeans(2)
68/13: kmeans.fit(x)
68/14: data_with_cluster = data.copy()
68/15:
data_with_cluster = data.copy()
data_with_cluster.head()
68/16:
data_with_cluster = kmeans.fit_predict(x)
data_with_cluster
68/17:
iden_cluster = kmeans.fit_predict(x)
iden_cluster
68/18:
data_with_cluster = data.copy()
data_with_cluster['Cluster'] = iden_cluster
data_with_cluster.head()
68/19: kmeans = KMeans(5)
68/20: kmeans.fit(x)
68/21:
iden_cluster = kmeans.fit_predict(x)
iden_cluster
68/22:
data_with_cluster = data.copy()
data_with_cluster['Cluster'] = iden_cluster
data_with_cluster.head()
68/23:
kmeans = KMeans(5)
kmeans.fit(x)
68/24:
kmeans = KMeans(5)
kmeans.fit(x)
68/25:
iden_cluster = kmeans.fit_predict(x)
iden_cluster
data_with_cluster = data.copy()
data_with_cluster['Cluster'] = iden_cluster


plt.scatter(data['Longitude'], data['Latitude'],c=data_with_clusters['Cluster'], cmap = 'rainbow')
plt.xlim(-180,180)
plt.ylim(-90, 90)
plt.show()
68/26:
iden_cluster = kmeans.fit_predict(x)
iden_cluster
data_with_cluster = data.copy()
data_with_cluster['Cluster'] = iden_cluster


plt.scatter(data['Longitude'], data['Latitude'],c=data_with_cluster['Cluster'], cmap = 'rainbow')
plt.xlim(-180,180)
plt.ylim(-90, 90)
plt.show()
68/27:
kmeans = KMeans(4)
kmeans.fit(x)
68/28:
iden_cluster = kmeans.fit_predict(x)
iden_cluster
data_with_cluster = data.copy()
data_with_cluster['Cluster'] = iden_cluster


plt.scatter(data['Longitude'], data['Latitude'],c=data_with_cluster['Cluster'], cmap = 'rainbow')
plt.xlim(-180,180)
plt.ylim(-90, 90)
plt.show()
68/29:
kmeans = KMeans(3)
kmeans.fit(x)
68/30:
iden_cluster = kmeans.fit_predict(x)
iden_cluster
data_with_cluster = data.copy()
data_with_cluster['Cluster'] = iden_cluster


plt.scatter(data['Longitude'], data['Latitude'],c=data_with_cluster['Cluster'], cmap = 'rainbow')
plt.xlim(-180,180)
plt.ylim(-90, 90)
plt.show()
68/31:
kmeans = KMeans(2)
kmeans.fit(x)
68/32:
iden_cluster = kmeans.fit_predict(x)
iden_cluster
data_with_cluster = data.copy()
data_with_cluster['Cluster'] = iden_cluster


plt.scatter(data['Longitude'], data['Latitude'],c=data_with_cluster['Cluster'], cmap = 'rainbow')
plt.xlim(-180,180)
plt.ylim(-90, 90)
plt.show()
68/33:
kmeans = KMeans(10)
kmeans.fit(x)
68/34:
iden_cluster = kmeans.fit_predict(x)
iden_cluster
data_with_cluster = data.copy()
data_with_cluster['Cluster'] = iden_cluster


plt.scatter(data['Longitude'], data['Latitude'],c=data_with_cluster['Cluster'], cmap = 'rainbow')
plt.xlim(-180,180)
plt.ylim(-90, 90)
plt.show()
68/35:
kmeans = KMeans(5)
kmeans.fit(x)
68/36:
iden_cluster = kmeans.fit_predict(x)
iden_cluster
data_with_cluster = data.copy()
data_with_cluster['Cluster'] = iden_cluster


plt.scatter(data['Longitude'], data['Latitude'],c=data_with_cluster['Cluster'], cmap = 'rainbow')
plt.xlim(-180,180)
plt.ylim(-90, 90)
plt.show()
68/37:
kmeans = KMeans(3)
kmeans.fit(x)
68/38:
iden_cluster = kmeans.fit_predict(x)
iden_cluster
data_with_cluster = data.copy()
data_with_cluster['Cluster'] = iden_cluster


plt.scatter(data['Longitude'], data['Latitude'],c=data_with_cluster['Cluster'], cmap = 'rainbow')
plt.xlim(-180,180)
plt.ylim(-90, 90)
plt.show()
68/39:
kmeans = KMeans(8)
kmeans.fit(x)
68/40:
iden_cluster = kmeans.fit_predict(x)
iden_cluster
data_with_cluster = data.copy()
data_with_cluster['Cluster'] = iden_cluster


plt.scatter(data['Longitude'], data['Latitude'],c=data_with_cluster['Cluster'], cmap = 'rainbow')
plt.xlim(-180,180)
plt.ylim(-90, 90)
plt.show()
71/1:
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.cluster import KMeans
71/2:
data = pd.read_csv( 'Categorical.csv')
data.head()
71/3:
raw_data = pd.read_csv( 'Categorical.csv')
raw_data.head()
71/4:
data = raw_data.copy()
data = data.drop(['Unnamed:0'], axis = 1)
71/5:
data = raw_data.copy()
data = data.drop(['Unnamed: 0'], axis = 1)
72/1:
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
sns.set()
from sklearn.cluster import KMeans
72/2:
# Load the data
raw_data = pd.read_csv('Categorical.csv')
# Check the data
raw_data
72/3:
data = raw_data.copy()
data = data.drop(['Unnamed: 0'], axis = 1)
72/4:
#data = raw_data.copy()
#data = data.drop(['Unnamed: 0'], axis = 1)
71/6:
#data = raw_data.copy()
#data = data.drop(['Unnamed: 0'], axis = 1)
71/7:
data_mapped =raw_data.copy()
data_mapped['continent'] = data_mapped['continent'].map({'North America':0,'Europe':2,'Asia':3,'South America':4, 'Oceania':5,'Seven seas (open ocean)':6, 'Antarctica':7})
71/8:
data_mapped =raw_data.copy()
data_mapped['continent'] = data_mapped['continent'].map({'North America':0,'Europe':2,'Asia':3,'South America':4, 'Oceania':5,'Seven seas (open ocean)':6, 'Antarctica':7})
data_mapped.head()
71/9:
data_mapped =raw_data.copy()
data_mapped['continent'] = data_mapped['continent'].map({'North America':0,'Europe':1,'Asia':2,'Africa':3,'South America':4, 'Oceania':5,'Seven seas (open ocean)':6, 'Antarctica':7})
data_mapped.head()
71/10: x = data_mapped
71/11: x = data_mapped[:,1:]
71/12: x = data_mapped[:,1:4]
71/13: x = data_mapped.iloc[:,1:]
71/14:
kmeans = KMeans(4)
kmeans.fit(x)
71/15: iden_clusters = kmeans.fit_predict(x)
71/16:
iden_clusters = kmeans.fit_predict(x)
iden_clusters
71/17:
data_clusters = data_mapped.copy()
data_clusters['clusters'] = iden_clusters
data_clusters.head()
71/18:
plt.scatter(data['Longitude'], data['Latitude'], c=data_clusters['clusters'], cmap = 'rainbow')
plt.xlim(-180,180)
plt.ylim(-90, 90)
plt.show()
74/1:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
sns.set()
from sklearn.cluster import KMeans
74/2:
# Load the data
raw_data = pd.read_csv('Countries_exercise.csv')
# Check the data
raw_data.head()
74/3:
# Load the data
raw_data = pd.read_csv('Countries-exercise.csv')
# Check the data
raw_data.head()
74/4:
plt.scatter(data['Longitude'], data['Latitude'])
plt.xlim(-180,180)
plt.ylim(-90, 90)
plt.show()
74/5:
plt.scatter(raw_data['Longitude'], raw_data['Latitude'])
plt.xlim(-180,180)
plt.ylim(-90, 90)
plt.show()
75/1:
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.cluster import KMeans
75/2:
raw_data = pd.read_csv( 'Categorical.csv')
raw_data.head()
74/6: x = raw_data.iloc[:,1:]
74/7:
kmeans = KMeans(4)
kmeans.fit(x)
74/8:
iden_clusters = kmeans.fit_predict(x)
iden_clusters
74/9:
data_clusters = data_mapped.copy()
data_clusters['clusters'] = iden_clusters
data_clusters.head()
74/10:
data_clusters = raw_data.copy()
data_clusters['clusters'] = iden_clusters
data_clusters.head()
74/11:
plt.scatter(data['Longitude'], data['Latitude'], c=data_clusters['clusters'], cmap = 'rainbow')
plt.xlim(-180,180)
plt.ylim(-90, 90)
plt.show()
74/12:
plt.scatter(data_clusters['Longitude'], data_clusters['Latitude'], c=data_clusters['clusters'], cmap = 'rainbow')
plt.xlim(-180,180)
plt.ylim(-90, 90)
plt.show()
74/13: kmeans.inertia_
74/14:
wcss = []
cl_num = 11
74/15:
wcss = []
cl_num = 11
74/16:
for i in range(1,cl_num)
    kmeans = KMeans(i)
    kmeans.fit(x)
    wcss.append(kmeans.inertia_)
74/17:
for i in range(1,cl_num):
    kmeans = KMeans(i)
    kmeans.fit(x)
    wcss.append(kmeans.inertia_)
74/18: wcss
74/19:
number_clusters = range(1,cl_num)
plt.plot(number_clusters, wcss)
plt.title('The Elbow Method')
plt.xlabel('Number of clusters')
plt.ylabel('Within-cluster Sum of Squares')
76/1:
import matplotlib.pyplot as plt
import seaborn as sns
sns.set_theme(style="darkgrid")

import numpy as np
import random
76/2:
import matplotlib.pyplot as plt
import seaborn as sns
sns.set_theme(style="darkgrid")

import numpy as np
import random
77/1:
import matplotlib.pyplot as plt
import seaborn as sns
sns.set_theme(style="darkgrid")

import numpy as np
import random
78/1:
import matplotlib.pyplot as plt
import seaborn as sns
sns.set_theme(style="darkgrid")

import numpy as np
import random
78/2:
import scipy.io
mat1 = scipy.io.loadmat('ex7data1.mat')
mat2 = scipy.io.loadmat('ex7data2.mat')
78/3:
k=3
initial_centroids = []
for i in range(3):
    initial_centroids.append([
        random.uniform(mat1['X'][:,0].min(), mat1['X'][:,0].max()),
        random.uniform(mat1['X'][:,1].min(), mat1['X'][:,1].max())])
    
initial_centroids = np.array(initial_centroids)
78/4:
plt.scatter(mat1['X'][:,0],mat1['X'][:,1])
plt.scatter(initial_centroids[:,0],initial_centroids[:,1], color=['red','green','orange'])
78/5:
plt.scatter(mat1['X'][:,0],mat1['X'][:,1])
plt.scatter(initial_centroids[:,0],initial_centroids[:,1], color=['red','green','orange'], marker='X')
78/6:
plt.scatter(mat1['X'][:,0],mat1['X'][:,1])
plt.scatter(initial_centroids[:,0],initial_centroids[:,1], color=['red','green','orange'], marker='x')
78/7:
X = mat1['X']
centroids = initial_centroids
78/8:
X = mat1['X']
centroids = initial_centroids
centroids
78/9:
def runkMeans(X, centroids):
    centroids_index = []
    for i in range(len(X)):
        sumSqrt=[]
        for k in range(len(centroids)):
            sumSqrt.append( np.sqrt(sum((X[i] - centroids[k])**2)) )
            
        centroids_index.append(sumSqrt.index(min(sumSqrt)))
        
    return centroids_index
78/10: rank=runkMeans(X,centroids)
78/11:
rank=runkMeans(X,centroids)
result
78/12:
rank=runkMeans(X,centroids)
rank
78/13: rank=runkMeans(X,centroids)
78/14: find(rank=2)
78/15: output = np.where(rank ==0)
78/16:
output = np.where(rank ==0)
output
78/17: rank
78/18:
output = np.where(rank[0] ==0)
output
78/19: rank[0]
78/20: rank[1]
78/21: rank[numpy.where(rank == 2)]
78/22: rank[np.where(rank == 2)]
78/23: rank[np.where(rank == 0)]
78/24:  list(filter(lambda x: (x  == 0), rank))
78/25:  list(filter(lambda x.index(): (x  == 0), rank))
78/26:  list(filter(lambda x : (x  == 0), rank))
78/27: a= list(filter(lambda x : (x  == 0), rank))
78/28: a.index()
78/29: a= list(filter(lambda x : (x  == 0), rank.index(x) ) )
78/30: [i for i ,v  in enumerate(l) if rank(v)]
78/31: [i for i ,v  in X if rank(v)==0]
78/32: [i for i   in X if rank(v)==0]
78/33: [i for i,j   in X if rank[j]=0]
78/34: [i for i,j   in X if rank[j]==0]
78/35: [i for i,j   range(len(x)) if rank[j]==0]
78/36: [i for i,j  in  range(len(x)) if rank[j]==0]
78/37: [i for i,j  in  range(len(X)) if rank[j]==0]
78/38: [i for i,j  in  enumerate(X) if rank[j]==0]
78/39: rank[0]
78/40: rank[1]
78/41: rank[1].index()
78/42: rank.index(1)
78/43: rank.index(2)
78/44: rank
78/45: [index for index, value in enumerate(rank) if value == 0]
78/46: X[index for index, value in enumerate(rank) if value == 0]
78/47: [index for index, value in enumerate(rank) if value == 0]
78/48: index_0 =  [index for index, value in enumerate(rank) if value == 0]
78/49: index_0
78/50: x[index_0]
78/51: X[index_0]
78/52: centroids_index
78/53: centroids
78/54: len(centroids)
78/55:
def calMeans(X, centroids_index):
    centroids_mean = []
    for i in range(len(centroids_index)):
        _index =  [index for index, value in enumerate(rank) if value == i]
        centroids_mean.append(statistics.mean(X[index_0]))
        plt.scatter(X[index_0][0],X[index_0][1], color= np.sqrt(20 * (i+1)) )
    plt.show()
    return centroids_mean
78/56: centroids
78/57: calMeans(X,centroids)
78/58:
import matplotlib.pyplot as plt
import seaborn as sns
sns.set_theme(style="darkgrid")

import numpy as np
import random
import statistics
78/59:
def calMeans(X, centroids_index):
    centroids_mean = []
    for i in range(len(centroids_index)):
        _index =  [index for index, value in enumerate(rank) if value == i]
        centroids_mean.append(statistics.mean(X[index_0]))
        plt.scatter(X[index_0][0],X[index_0][1], color= np.sqrt(20 * (i+1)) )
    plt.show()
    return centroids_mean
78/60: calMeans(X,centroids)
78/61:
def calMeans(X, centroids_index):
    centroids_mean = []
    for i in range(len(centroids_index)):
        _index =  [index for index, value in enumerate(rank) if value == i]
        #print(X[_index])
        centroids_mean.append(statistics.mean(X[_index]))
        plt.scatter(X[index_0][0],X[index_0][1], color= np.sqrt(20 * (i+1)) )
    plt.show()
    return centroids_mean
78/62: calMeans(X,centroids)
78/63:
def calMeans(X, centroids_index):
    centroids_mean = []
    for i in range(len(centroids_index)):
        _index =  [index for index, value in enumerate(rank) if value == i]
        print(X[_index])
        #centroids_mean.append(statistics.mean(X[_index]))
        plt.scatter(X[index_0][0],X[index_0][1], color= np.sqrt(20 * (i+1)) )
    plt.show()
    return centroids_mean
78/64: _index =  [index for index, value in enumerate(rank) if value == 0]
78/65: _index
78/66: X[_index]
78/67:
def calMeans(X, centroids_index):
    centroids_mean = []
    for i in range(len(centroids_index)):
        _index =  [index for index, value in enumerate(rank) if value == i]
        X[_index]
        #centroids_mean.append(statistics.mean(X[_index]))
        plt.scatter(X[index_0][0],X[index_0][1], color= np.sqrt(20 * (i+1)) )
    plt.show()
    return centroids_mean
78/68: calMeans(X,centroids)
78/69:
def calMeans(X, centroids_index):
    centroids_mean = []
    for i in range(len(centroids_index)):
        _index =  [index for index, value in enumerate(rank) if value == i]
        statistics.mean(X[_index])
        #centroids_mean.append(statistics.mean(X[_index]))
        plt.scatter(X[index_0][0],X[index_0][1], color= np.sqrt(20 * (i+1)) )
    plt.show()
    return centroids_mean
78/70: calMeans(X,centroids)
78/71:
def calMeans(X, centroids_index):
    centroids_mean = []
    for i in range(len(centroids_index)):
        _index =  [index for index, value in enumerate(rank) if value == i]
        sum(X[_index])
        #centroids_mean.append(statistics.mean(X[_index]))
        plt.scatter(X[index_0][0],X[index_0][1], color= np.sqrt(20 * (i+1)) )
    plt.show()
    return centroids_mean
78/72: calMeans(X,centroids)
78/73:
def calMeans(X, centroids_index):
    centroids_mean = []
    for i in range(len(centroids_index)):
        _index =  [index for index, value in enumerate(rank) if value == i]
        centroids_mean.append(sum(X[_index])/len(_index))
        plt.scatter(X[index_0][0],X[index_0][1], color= np.sqrt(20 * (i+1)) )
    plt.show()
    return centroids_mean
78/74: calMeans(X,centroids)
78/75:
def calMeans(X, centroids_index):
    centroids_mean = []
    for i in range(len(centroids_index)):
        _index =  [index for index, value in enumerate(rank) if value == i]
        centroids_mean.append(sum(X[_index])/len(_index))
        plt.scatter(X[index_0][0],X[index_0][1], color= np.sqrt(20 * (i+1)) )
    return centroids_mean
78/76:
def calMeans(X, centroids_index):
    centroids_mean = []
    for i in range(len(centroids_index)):
        _index =  [index for index, value in enumerate(rank) if value == i]
        centroids_mean.append(sum(X[_index])/len(_index))
        plt.scatter(X[_index][0],X[_index][1], color= np.sqrt(20 * (i+1)) )
    return centroids_mean
78/77: calMeans(X,centroids)
78/78: plt.scatter(X[_index][0],X[_index][1], color= np.sqrt(20 * (i+1)) )
78/79: X[_index][0]
78/80: X[_index][:,1]
78/81:
def calMeans(X, centroids_index):
    centroids_mean = []
    for i in range(len(centroids_index)):
        _index =  [index for index, value in enumerate(rank) if value == i]
        centroids_mean.append(sum(X[_index])/len(_index))
        plt.scatter(X[_index][:,1],X[_index][:,1], color= np.sqrt(20 * (i+1)) )
    return centroids_mean
78/82: calMeans(X,centroids)
78/83:
def calMeans(X, centroids_index):
    centroids_mean = []
    for i in range(len(centroids_index)):
        _index =  [index for index, value in enumerate(rank) if value == i]
        centroids_mean.append(sum(X[_index])/len(_index))
        plt.scatter(X[_index][:,0],X[_index][:,1], color= np.sqrt(20 * (i+1)) )
    return centroids_mean
78/84: calMeans(X,centroids)
78/85: plt.scatter(X[_index][:,0],X[_index][:,1], color= np.sqrt(20 * (i+1)) )
78/86: X[_index][:,1]
78/87: X[_index][:,0]
78/88: plt.scatter(  X[_index][:,0] , X[_index][:,1]  )
78/89: plt.scatter(  X[_index][:,0] , X[_index][:,1]  , color= np.sqrt(20 * (0+1)))
78/90: plt.scatter(  X[_index][:,0] , X[_index][:,1]  , c= np.sqrt(20 * (0+1)))
78/91:

c = np.sqrt( (20 * np.random.rand(N))**2)
plt.scatter(  X[_index][:,0] , X[_index][:,1]  , c= c)
78/92:

c = np.sqrt( (20 * np.random.rand(1))**2)
plt.scatter(  X[_index][:,0] , X[_index][:,1]  , c= c)
78/93:

c = np.sqrt( (20 * np.random.rand(1))**2)
plt.scatter(  X[_index][:,0] , X[_index][:,1]  , color= c)
78/94:

c = np.random.rand(4, 30)
plt.scatter(  X[_index][:,0] , X[_index][:,1]  , c= c)
78/95:

c = np.random.rand(0,1)
plt.scatter(  X[_index][:,0] , X[_index][:,1]  , c= c)
78/96:

c = np.random.rand(0)
plt.scatter(  X[_index][:,0] , X[_index][:,1]  , c= c)
78/97:

c = np.random.rand(1)
plt.scatter(  X[_index][:,0] , X[_index][:,1]  , c= c)
78/98:

c = 1
plt.scatter(  X[_index][:,0] , X[_index][:,1]  , c= c)
78/99:

c = 0.5
plt.scatter(  X[_index][:,0] , X[_index][:,1]  , c= c)
78/100:

c = 0.5
plt.scatter(  X[_index][:,0] , X[_index][:,1]  , c = c/255)
78/101:

c = 0.5
plt.scatter(  X[_index][:,0] , X[_index][:,1]  , c = c/255)
78/102:

c = 0.5
plt.scatter(  X[_index][:,0] , X[_index][:,1]  , color = c/255)
78/103:

c = 0.5
plt.scatter(  X[_index][:,0] , X[_index][:,1]  , color =255)
78/104:

color=plt.rainbow(np.linspace(0,1,1))
plt.scatter(  X[_index][:,0] , X[_index][:,1]  , color =255)
78/105:

color=plt.cm.rainbow(np.linspace(0,1,1))
plt.scatter(  X[_index][:,0] , X[_index][:,1]  , color =255)
78/106:
my_cmap = matplotlib.colors.LinearSegmentedColormap('my_colormap',cdict,256)
plt.scatter(  X[_index][:,0] , X[_index][:,1]  , cmap=my_cmap)
78/107:
my_cmap = plt.colors.LinearSegmentedColormap('my_colormap',cdict,256)
plt.scatter(  X[_index][:,0] , X[_index][:,1]  , cmap=my_cmap)
78/108:
import matplotlib.cm as cm
colors = cm.rainbow(np.linspace(0, 1, len(k)))
78/109:
import matplotlib.cm as cm
colors = cm.rainbow(np.linspace(0, 1, 3))
78/110:
import matplotlib.cm as cm
colors = cm.rainbow(np.linspace(0, 1, 3))
colors
78/111: plt.scatter(  X[_index][:,0] , X[_index][:,1]  , cmap=colors[1])
78/112: plt.scatter(  X[_index][:,0] , X[_index][:,1]  , cmap=colors[2])
78/113:
import matplotlib.cm as cm
colors = cm.rainbow(np.linspace(0, 1, 255))
colors
78/114: plt.scatter(  X[_index][:,0] , X[_index][:,1]  , cmap=colors[100])
79/1:
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
sns.set()
from sklearn.cluster import KMeans
79/2:
# Load the data
data = pd.read_csv('iris_dataset.csv')
# Check the data
data
79/3:
# Load the data
data = pd.read_csv('iris-dataset.csv')
# Check the data
data
79/4:
# create a scatter plot based on two corresponding features (sepal_length and sepal_width; OR petal_length and petal_width)
plt.scatter(data['sepal_length'],data['sepal_width'])
# name your axes
plt.xlabel('Lenght of sepal')
plt.ylabel('Width of sepal')
plt.show()
79/5:
# create a variable which will contain the data for the clustering
x = data.copy()
# create a k-means object with 2 clusters
kmeans = KMeans(2)
# fit the data
kmeans.fit(x)
79/6:
# create a copy of data, so we can see the clusters next to the original data
clusters = data.copy()
# predict the cluster for each observation
clusters['cluster_pred']=kmeans.fit_predict(x)
79/7:
# create a scatter plot based on two corresponding features (sepal_length and sepal_width; OR petal_length and petal_width)
plt.scatter(clusters['sepal_length'], clusters['sepal_width'], c= clusters ['cluster_pred'], cmap = 'rainbow')
78/115: plt.scatter(  X[_index][:,0] , X[_index][:,1]  , cmap = 'rainbow')
78/116:
cmaps = [
            'Greys', 'Purples', 'Blues', 'Greens', 'Oranges', 'Reds',
            'YlOrBr', 'YlOrRd', 'OrRd', 'PuRd', 'RdPu', 'BuPu',
            'GnBu', 'PuBu', 'YlGnBu', 'PuBuGn', 'BuGn', 'YlGn']
78/117:
cmaps = [
            'Greys', 'Purples', 'Blues', 'Greens', 'Oranges', 'Reds',
            'YlOrBr', 'YlOrRd', 'OrRd', 'PuRd', 'RdPu', 'BuPu',
            'GnBu', 'PuBu', 'YlGnBu', 'PuBuGn', 'BuGn', 'YlGn']
cmaps[1]
78/118: plt.scatter(  X[_index][:,0] , X[_index][:,1]  , color = 255,255,255)
78/119: X[_index][:,0]
78/120: X[_index][:,1]
78/121: plt.scatter(  X[_index][:,0] , X[_index][:,1] )
78/122: plt.scatter(  X[_index][:,0] , X[_index][:,1]  , color = '255,255,255')
78/123: plt.scatter(  X[_index][:,0] , X[_index][:,1]  , color = (1, 0, 0))
78/124: plt.scatter(  X[_index][:,0] , X[_index][:,1]  , color = (255, 0, 0))
78/125: plt.scatter(  X[_index][:,0] , X[_index][:,1]  , color = (250, 0, 0))
78/126: plt.scatter(  X[_index][:,0] , X[_index][:,1]  , c = (250, 0, 0))
78/127: plt.scatter(  X[_index][:,0] , X[_index][:,1]  , color = (250, 0, 0))
78/128:
cn = mcd.CSS4_COLORS[1]
plt.scatter(  X[_index][:,0] , X[_index][:,1]  , color = cn)
78/129:
import matplotlib.pyplot as plt
import matplotlib._color_data as mcd
import seaborn as sns
sns.set_theme(style="darkgrid")

import numpy as np
import random
import statistics
78/130:
cn = mcd.CSS4_COLORS[1]
plt.scatter(  X[_index][:,0] , X[_index][:,1]  , color = cn)
78/131:

overlap = {name for name in mcd.CSS4_COLORS
           if "xkcd:" + name in mcd.XKCD_COLORS}
78/132: overlap[10]
78/133: overlap
78/134: overlap[n]
78/135:

overlap = [name for name in mcd.CSS4_COLORS
           if "xkcd:" + name in mcd.XKCD_COLORS]
78/136: overlap[1]
78/137:
overlap = [name for name in mcd.CSS4_COLORSif "xkcd:" + name in mcd.XKCD_COLORS]
plt.scatter(  X[_index][:,0] , X[_index][:,1]  , color = overlap[1])
78/138:

overlap = [name for name in mcd.CSS4_COLORS
           if "xkcd:" + name in mcd.XKCD_COLORS]
78/139:
overlap = [name for name in mcd.CSS4_COLORS
           if "xkcd:" + name in mcd.XKCD_COLORS]
plt.scatter(  X[_index][:,0] , X[_index][:,1]  , color = overlap[1])
78/140:
def calMeans(X, centroids_index):
    centroids_mean = []
    overlap = [name for name in mcd.CSS4_COLORS
           if "xkcd:" + name in mcd.XKCD_COLORS]
    for i in range(len(centroids_index)):
        _index =  [index for index, value in enumerate(rank) if value == i]
        centroids_mean.append(sum(X[_index])/len(_index))
        plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i] )
    return centroids_mean
78/141: calMeans(X,centroids)
78/142:
def calMeans(X, centroids_index):
    centroids_mean = []
    overlap = [name for name in mcd.CSS4_COLORS
           if "xkcd:" + name in mcd.XKCD_COLORS]
    for i in range(len(centroids_index)):
        _index =  [index for index, value in enumerate(rank) if value == i]
        centroids_mean.append(sum(X[_index])/len(_index))
        plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i+3] )
    return centroids_mean
78/143: calMeans(X,centroids)
78/144:
def calMeans(X, centroids_index):
    centroids_mean = []
    overlap = [name for name in mcd.CSS4_COLORS
           if "xkcd:" + name in mcd.XKCD_COLORS]
    for i in range(len(centroids_index)):
        _index =  [index for index, value in enumerate(rank) if value == i]
        centroids_mean.append(sum(X[_index])/len(_index))
        plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i+4] )
    return centroids_mean
78/145: calMeans(X,centroids)
78/146:

plt.scatter(  X[_index][:,0] , X[_index][:,1]  , )
78/147: overlap[1]
78/148: centroids[:,1]
78/149:
centroids_index = runkMeans(X, centroids)
NewCentroids = calMeans(X,centroids_index)
centroids = NewCentroids

plt.scatter(centroids[:,0],centroids[:,1], color = overlap[i+4] )
#time.sleep(5)
78/150:
def runkMeans(X, centroids):
    centroids_index = []
    for i in range(len(X)):
        sumSqrt=[]
        for k in range(len(centroids)):
            sumSqrt.append( np.sqrt(sum((X[i] - centroids[k])**2)) )
            
        centroids_index.append(sumSqrt.index(min(sumSqrt)))
        
    return centroids_index
78/151:
def calMeans(X, centroids_index):
    centroids_mean = []
    overlap = [name for name in mcd.CSS4_COLORS
           if "xkcd:" + name in mcd.XKCD_COLORS]
    for i in range(len(centroids_index)):
        _index =  [index for index, value in enumerate(rank) if value == i]
        centroids_mean.append(sum(X[_index])/len(_index))
        plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i+4] )
    return centroids_mean
78/152:
X = mat1['X']
centroids = initial_centroids
78/153:
centroids_index = runkMeans(X, centroids)
NewCentroids = calMeans(X,centroids_index)
centroids = NewCentroids

plt.scatter(centroids[:,0],centroids[:,1], color = overlap[i+4] )
#time.sleep(5)
78/154:
def calMeans(X, centroids_index):
    centroids_mean = []
    overlap = [name for name in mcd.CSS4_COLORS
           if "xkcd:" + name in mcd.XKCD_COLORS]
    for i in range(len(centroids_index)):
        _index =  [index for index, value in enumerate(rank) if value == i]
        if(len(_index)>0):
            centroids_mean.append(sum(X[_index])/len(_index))
            plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i+4] )
    return centroids_mean
78/155:
X = mat1['X']
centroids = initial_centroids
78/156:
centroids_index = runkMeans(X, centroids)
NewCentroids = calMeans(X,centroids_index)
centroids = NewCentroids

plt.scatter(centroids[:,0],centroids[:,1], color = overlap[i+4] )
#time.sleep(5)
78/157:
global  overlap = [name for name in mcd.CSS4_COLORS
           if "xkcd:" + name in mcd.XKCD_COLORS]
78/158: global  overlap
78/159:
global  overlap 
overlap = [name for name in mcd.CSS4_COLORS
           if "xkcd:" + name in mcd.XKCD_COLORS]
78/160:
centroids_index = runkMeans(X, centroids)
NewCentroids = calMeans(X,centroids_index)
centroids = NewCentroids
plt.scatter(centroids[:,0],centroids[:,1], overlap[i+4] , marker='x')
#time.sleep(5)
78/161: centroids[:,0]
78/162: centroids[]
78/163: centroids
78/164:
_index =  [index for index, value in enumerate(rank) if value == i]
if(len(_index)>0):
    centroids_mean.append(sum(X[_index])/len(_index))
78/165:
centroids_mean=[]
_index =  [index for index, value in enumerate(rank) if value == i]

centroids_mean.append(sum(X[_index])/len(_index))
78/166:
_index =  [index for index, value in enumerate(rank) if value == 0]
centroids_mean.append(sum(X[_index])/len(_index))
78/167: centroids_mean
78/168: centroids_mean=[]
78/169:
_index =  [index for index, value in enumerate(rank) if value == 0]
centroids_mean.append(sum(X[_index])/len(_index))
78/170: centroids_mean
78/171:
_index =  [index for index, value in enumerate(rank) if value == 0]
centroids_mean.append(sum(X[_index])/len(_index))
78/172: centroids_mean
78/173: centroids_mean=[]
78/174:
_index =  [index for index, value in enumerate(rank) if value == 0]
np.append(centroids_mean,(sum(X[_index])/len(_index)))
78/175:
_index =  [index for index, value in enumerate(rank) if value == 1]
np.append(centroids_mean,(sum(X[_index])/len(_index)))
78/176:
_index =  [index for index, value in enumerate(rank) if value == 1]
np.append(centroids_mean,(sum(X[_index])/len(_index)))
78/177:
_index =  [index for index, value in enumerate(rank) if value == 1]
np.append(centroids_mean,(sum(X[_index])/len(_index)))
78/178: centroids_mean=[]
78/179:
_index =  [index for index, value in enumerate(rank) if value == 1]
np.concatenate((centroids_mean,  sum(X[_index])/len(_index)), axis=0)
78/180: centroids_mean
78/181:
_index =  [index for index, value in enumerate(rank) if value == 1]
np.concatenate((centroids_mean,  sum(X[_index])/len(_index)), axis=0)
78/182:
_index =  [index for index, value in enumerate(rank) if value == 1]
np.concatenate((centroids_mean,  sum(X[_index])/len(_index)), axis=0)
78/183:
_index =  [index for index, value in enumerate(rank) if value == 1]
mean = sum(X[_index])/len(_index)
np.concatenate(centroids_mean, mean , axis=0)
78/184:
_index =  [index for index, value in enumerate(rank) if value == 1]
mean = sum(X[_index])/len(_index)
np.concatenate(centroids_mean, mean , axis=1)
78/185:
_index =  [index for index, value in enumerate(rank) if value == 1]
mean = sum(X[_index])/len(_index)
np.append(centroids_mean, mean )
78/186:
_index =  [index for index, value in enumerate(rank) if value == 1]
mean = sum(X[_index])/len(_index)
np.append(centroids_mean, mean )
78/187:
_index =  [index for index, value in enumerate(rank) if value == 1]
mean = sum(X[_index])/len(_index)
np.append(centroids_mean, mean )
78/188:
arr1 = np.array([[1, 2], [3, 4]])
arr2 = np.array([[10, 20], [30, 40]])

# no axis provided, array elements will be flattened
arr_flat = np.append(arr1, arr2)
78/189: arr_flat
78/190:
np.array(arr_flat)
arr1 = np.array([[1, 2], [3, 4]])
arr2 = np.array([[10, 20], [30, 40]])

# no axis provided, array elements will be flattened
arr_flat = np.concatenate(arr1, arr2)
78/191:
arr_flat =np.array([])
arr1 = np.array([[1, 2], [3, 4]])
arr2 = np.array([[10, 20], [30, 40]])

# no axis provided, array elements will be flattened
arr_flat = np.concatenate(arr1, arr2)
78/192:
arr_flat =np.array([])
arr1 = np.array([[1, 2], [3, 4]])
arr2 = np.array([[10, 20], [30, 40]])
|
# no axis provided, array elements will be flattened
arr_flat = np.append(arr1, arr2)
78/193:
arr_flat =np.array([])
arr1 = np.array([[1, 2], [3, 4]])
arr2 = np.array([[10, 20], [30, 40]])

# no axis provided, array elements will be flattened
arr_flat = np.append(arr1, arr2)
78/194: arr_flat
78/195:
arr_flat =np.array([])
arr1 = np.array([[1, 2], [3, 4]])
arr2 = np.array([[10, 20], [30, 40]])

# no axis provided, array elements will be flattened
arr_flat = np.append(arr1, arr2,axis=0)
78/196: arr_flat
78/197:
def calMeans(X, centroids_index):
    centroids_mean  =np.array([])
    for i in range(len(centroids_index)):
        _index =  [index for index, value in enumerate(rank) if value == i]
        if(len(_index)>0):
            centroids_mean = np.append(centroids_mean, [(]sum(X[_index])/len(_index)],axis=0)
            plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i+4] )
    return centroids_mean
78/198:
def calMeans(X, centroids_index):
    centroids_mean  =np.array([])
    for i in range(len(centroids_index)):
        _index =  [index for index, value in enumerate(rank) if value == i]
        if(len(_index)>0):
            centroids_mean = np.append(centroids_mean, [sum(X[_index])/len(_index)],axis=0)
            plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i+4] )
    return centroids_mean
78/199:
centroids_index = runkMeans(X, centroids)
NewCentroids = calMeans(X,centroids_index)
centroids = NewCentroids
plt.scatter(centroids[:,0],centroids[:,1], overlap[i+4] , marker='x')
#time.sleep(5)
78/200:
centroids_mean  =np.array([])
for i in range(len(centroids_index)):
    _index =  [index for index, value in enumerate(rank) if value == i]
    if(len(_index)>0):
        centroids_mean = np.append(centroids_mean, [sum(X[_index])/len(_index)],axis=0)
        plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i+4] )
78/201:
centroids_mean  =np.array([])
for i in range(len(centroids_index)):
    _index =  [index for index, value in enumerate(rank) if value == i]
    if(len(_index)>0):
        centroids_mean = np.append(centroids_mean, [sum(X[_index])/len(_index)],axis=0)
        print(centroids_mean)
        plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i+4] )
78/202:
centroids_mean  =np.array([])
for i in range(len(centroids_index)):
    _index =  [index for index, value in enumerate(rank) if value == i]
    if(len(_index)>0):
        centroids_mean = np.append(centroids_mean, sum(X[_index])/len(_index),axis=0)
        print(centroids_mean)
        plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i+4] )
78/203:
centroids_mean  =np.array([])
for i in range(len(centroids_index)):
    _index =  [index for index, value in enumerate(rank) if value == i]
    if(len(_index)>0):
        centroids_mean = np.append(centroids_mean, sum(X[_index])/len(_index),axis=0)
        plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i+4] )
78/204: centroids_mean[1]
78/205: centroids_mean
78/206:
centroids_mean  =np.array([])
for i in range(len(centroids_index)):
    _index =  [index for index, value in enumerate(rank) if value == i]
    if(len(_index)>0):
        centroids_mean = np.append(centroids_mean, sum(X[_index])/len(_index),axis=1)
        plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i+4] )
78/207:
centroids_mean  =np.array([])
for i in range(len(centroids_index)):
    _index =  [index for index, value in enumerate(rank) if value == i]
    if(len(_index)>0):
        centroids_mean =centroids_mean ,[sum(X[_index])/len(_index)]
        plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i+4] )
78/208: centroids_mean
78/209: centroids_mean[0]
78/210:
centroids_mean  = []
for i in range(len(centroids_index)):
    _index =  [index for index, value in enumerate(rank) if value == i]
    if(len(_index)>0):
        centroids_mean =centroids_mean ,[sum(X[_index])/len(_index)]
        plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i+4] )
78/211: centroids_mean[0]
78/212: centroids_mean[0]
78/213: centroids_mean
78/214:
centroids_mean  = []
for i in range(len(centroids_index)):
    _index =  [index for index, value in enumerate(rank) if value == i]
    if(len(_index)>0):
        print(centroids_mean)
        print([sum(X[_index])/len(_index)])
        print('...')
        centroids_mean =centroids_mean ,[sum(X[_index])/len(_index)]
        plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i+4] )
78/215:
centroids_mean  = []
for i in range(len(centroids_index)):
    _index =  [index for index, value in enumerate(rank) if value == i]
    if(len(_index)>0):
        print(centroids_mean)
        print([sum(X[_index])/len(_index)])
        print('...')
        entroids_mean .append([sum(X[_index])/len(_index)])
        plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i+4] )
78/216:
centroids_mean  = []
for i in range(len(centroids_index)):
    _index =  [index for index, value in enumerate(rank) if value == i]
    if(len(_index)>0):
        print(centroids_mean)
        print([sum(X[_index])/len(_index)])
        print('...')
        entroids_mean.append([sum(X[_index])/len(_index)])
        plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i+4] )
78/217:
centroids_mean  = []
for i in range(len(centroids_index)):
    _index =  [index for index, value in enumerate(rank) if value == i]
    if(len(_index)>0):
        print(centroids_mean)
        print([sum(X[_index])/len(_index)])
        print('...')
        np.append(centroids_mean,[sum(X[_index])/len(_index)])
        plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i+4] )
78/218:
centroids_mean  = []
for i in range(len(centroids_index)):
    _index =  [index for index, value in enumerate(rank) if value == i]
    if(len(_index)>0):
        print(centroids_mean)
        print([sum(X[_index])/len(_index)])
        print('...')
        
        np.append(centroids_mean,[sum(X[_index])/len(_index)])
        plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i+4] )
78/219: centroids_mean
78/220: centroids_mean
78/221:
centroids_mean  = []
for i in range(len(centroids_index)):
    _index =  [index for index, value in enumerate(rank) if value == i]
    if(len(_index)>0):
        print(centroids_mean)
        print([sum(X[_index])/len(_index)])
        print('...')
        
        np.append(centroids_mean,[sum(X[_index])/len(_index)],axis=0)
        plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i+4] )
78/222:
centroids_mean  = []
for i in range(len(centroids_index)):
    _index =  [index for index, value in enumerate(rank) if value == i]
    if(len(_index)>0):
        print(centroids_mean)
        print([sum(X[_index])/len(_index)])
        print('...')
        
        np.append(centroids_mean,[sum(X[_index])/len(_index)],axis=1)
        plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i+4] )
78/223:
centroids_mean  = []
for i in range(len(centroids_index)):
    _index =  [index for index, value in enumerate(rank) if value == i]
    if(len(_index)>0):
        print(centroids_mean)
        print([sum(X[_index])/len(_index)])
        print('...')
        
        np.append(centroids_mean,sum(X[_index])/len(_index),axis=1)
        plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i+4] )
78/224:
centroids_mean  = []
for i in range(len(centroids_index)):
    _index =  [index for index, value in enumerate(rank) if value == i]
    if(len(_index)>0):
        print(centroids_mean)
        print([sum(X[_index])/len(_index)])
        print('...')
        
        np.append(centroids_mean,sum(X[_index])/len(_index),axis=0)
        plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i+4] )
78/225: centroids_mean
78/226:
centroids_mean  = []
for i in range(len(centroids_index)):
    _index =  [index for index, value in enumerate(rank) if value == i]
    if(len(_index)>0):
        print(i)
        print(centroids_mean)
        print([sum(X[_index])/len(_index)])
        print('...')
        
        np.append(centroids_mean,sum(X[_index])/len(_index),axis=0)
        plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i+4] )
78/227:
centroids_mean  = []
for i in range(len(centroids_index)):
    _index =  [index for index, value in enumerate(rank) if value == i]
    if(len(_index)>0):
        print(i)
        print(centroids_mean)
        print([sum(X[_index])/len(_index)])
        print('...')
        np.concatenate((centroids_mean,sum(X[_index])/len(_index)),axis=1)

        plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i+4] )
78/228:
centroids_mean  = []
for i in range(len(centroids_index)):
    _index =  [index for index, value in enumerate(rank) if value == i]
    if(len(_index)>0):
        print(i)
        print(centroids_mean)
        print([sum(X[_index])/len(_index)])
        print('...')
        np.concatenate((centroids_mean,sum(X[_index])/len(_index)),axis=0)

        plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i+4] )
78/229:
centroids_mean  = []
for i in range(len(centroids_index)):
    _index =  [index for index, value in enumerate(rank) if value == i]
    if(len(_index)>0):
        print(i)
        print(centroids_mean)
        print([sum(X[_index])/len(_index)])
        print('...')
        centroids_mean=np.concatenate((centroids_mean,sum(X[_index])/len(_index)),axis=0)

        plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i+4] )
78/230: centroids_mean
78/231:
centroids_mean  = []
for i in range(len(centroids_index)):
    _index =  [index for index, value in enumerate(rank) if value == i]
    if(len(_index)>0):
        print(i)
        print(centroids_mean)
        print([sum(X[_index])/len(_index)])
        print('...')
        centroids_mean=np.concatenate((centroids_mean,sum(X[_index])/len(_index)),axis=1)

        plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i+4] )
78/232:
def calMeans(X, centroids_index):
    centroids_mean  =np.array([])
    for i in range(len(centroids_index)):
        _index =  [index for index, value in enumerate(rank) if value == i]
        if(len(_index)>0):
            centroids_mean = np.append(centroids_mean, sum(X[_index])/len(_index),axis=1)
            plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i+4] )
    return centroids_mean
78/233:
centroids_mean  = []
for i in range(len(centroids_index)):
    _index =  [index for index, value in enumerate(rank) if value == i]
    if(len(_index)>0):
        print(i)
        print(centroids_mean)
        print([sum(X[_index])/len(_index)])
        print('...')
        centroids_mean=np.concatenate((centroids_mean,sum(X[_index])/len(_index)),axis=0)

        plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i+4] )
78/234:
centroids_mean  = []
for i in range(len(centroids_index)):
    _index =  [index for index, value in enumerate(rank) if value == i]
    if(len(_index)>0):
        print(i)
        print(centroids_mean)
        print([sum(X[_index])/len(_index)])
        print('...')
        centroids_mean=np.concatenate((centroids_mean,[sum(X[_index])/len(_index)]),axis=0)

        plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i+4] )
78/235:
centroids_mean  = []
for i in range(len(centroids_index)):
    _index =  [index for index, value in enumerate(rank) if value == i]
    if(len(_index)>0):
        print(i)
        print(centroids_mean)
        print([sum(X[_index])/len(_index)])
        print('...')
        centroids_mean=np.concatenate((centroids_mean,[sum(X[_index])/len(_index)]),axis=1)

        plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i+4] )
78/236:
centroids_mean  = []
for i in range(len(centroids_index)):
    _index =  [index for index, value in enumerate(rank) if value == i]
    if(len(_index)>0):
        print(i)
        print(centroids_mean)
        print([sum(X[_index])/len(_index)])
        print('...')
        centroids_mean=np.concatenate((centroids_mean,sum(X[_index])/len(_index)),axis=1)

        plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i+4] )
78/237:
centroids_mean  = []
for i in range(len(centroids_index)):
    _index =  [index for index, value in enumerate(rank) if value == i]
    if(len(_index)>0):
        print(i)
        print(centroids_mean)
        print([sum(X[_index])/len(_index)])
        print('...')
        centroids_mean=np.concatenate((centroids_mean,sum(X[_index])/len(_index)),axis=1)

        plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i+4] )
78/238:
centroids_mean  = []
for i in range(len(centroids_index)):
    _index =  [index for index, value in enumerate(rank) if value == i]
    if(len(_index)>0):
        print(i)
        print(centroids_mean)
        print([sum(X[_index])/len(_index)])
        print('...')
        centroids_mean=np.concatenate((centroids_mean,sum(X[_index])/len(_index)))

        plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i+4] )
78/239: centroids_mean
78/240:
centroids_mean  = []
for i in range(len(centroids_index)):
    _index =  [index for index, value in enumerate(rank) if value == i]
    if(len(_index)>0):
        centroids_mean=np.concatenate((centroids_mean,sum(X[_index])/len(_index)))
        centroids_mean = centroids_mean.reshape(k,len(centroids_mean)/k)
        plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i+4] )
78/241:
centroids_mean  = []
for i in range(len(centroids_index)):
    _index =  [index for index, value in enumerate(rank) if value == i]
    if(len(_index)>0):
        centroids_mean=np.concatenate((centroids_mean,sum(X[_index])/len(_index)))
        centroids_mean = centroids_mean.reshape(k,int(len(centroids_mean)/k)
        plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i+4] )
78/242: centroids_mean
78/243:
centroids_mean  = []
for i in range(len(centroids_index)):
    _index =  [index for index, value in enumerate(rank) if value == i]
    if(len(_index)>0):
        centroids_mean=np.concatenate((centroids_mean,sum(X[_index])/len(_index)))
        centroids_mean = centroids_mean.reshape(k,int(len(centroids_mean)/k)
78/244:
centroids_mean  = []
for i in range(len(centroids_index)):
    _index =  [index for index, value in enumerate(rank) if value == i]
    if(len(_index)>0):
        centroids_mean=np.concatenate((centroids_mean,sum(X[_index])/len(_index)))
78/245:
centroids_mean  = []
for i in range(len(centroids_index)):
    _index =  [index for index, value in enumerate(rank) if value == i]
    if(len(_index)>0):
        centroids_mean = np.stack((centroids_mean, sum(X[_index])/len(_index)), axis=0)
        plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i+4] )
78/246:
centroids_mean  = []
for i in range(len(centroids_index)):
    _index =  [index for index, value in enumerate(rank) if value == i]
    if(len(_index)>0):
        print(centroids_mean)
        print(sum(X[_index])/len(_index))
        centroids_mean = np.stack((centroids_mean, sum(X[_index])/len(_index)), axis=0)
        plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i+4] )
78/247:
centroids_mean  = []
for i in range(len(centroids_index)):
    _index =  [index for index, value in enumerate(rank) if value == i]
    if(len(_index)>0):
        print(centroids_mean)
        print(sum(X[_index])/len(_index))
        print('..)'
        centroids_mean = np.stack((centroids_mean, sum(X[_index])/len(_index)), axis=0)
        plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i+4] )
78/248:
centroids_mean  = []
for i in range(len(centroids_index)):
    _index =  [index for index, value in enumerate(rank) if value == i]
    if(len(_index)>0):
        print(centroids_mean)
        print(sum(X[_index])/len(_index))
        print('..)')
        centroids_mean = np.stack((centroids_mean, sum(X[_index])/len(_index)), axis=0)
        plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i+4] )
78/249:
centroids_mean  = []
for i in range(len(centroids_index)):
    _index =  [index for index, value in enumerate(rank) if value == i]
    if(len(_index)>0):
        centroids_mean = centroids_mean ,sum(X[_index])/len(_index)
        plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i+4] )
78/250: centroids_mean
78/251: np.concatenate(centroids_mean)
78/252: type(centroids_mean)
78/253:
centroids_mean  = []
for i in range(len(centroids_index)):
    _index =  [index for index, value in enumerate(rank) if value == i]
    if(len(_index)>0):
        centroids_mean.append( sum(X[_index])/len(_index) )
        plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i+4] )
78/254: type(centroids_mean)
78/255:
arr = np.vstack(centroids_mean)
arr
78/256:
def calMeans(X, centroids_index):
    centroids_mean  =np.array([])
    for i in range(len(centroids_index)):
        _index =  [index for index, value in enumerate(rank) if value == i]
        if(len(_index)>0):
            centroids_mean.append( sum(X[_index])/len(_index) )
            plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i+4] )
    
    return np.vstack(centroids_mean)
78/257:
X = mat1['X']
centroids = initial_centroids
78/258:
centroids_index = runkMeans(X, centroids)
NewCentroids = calMeans(X,centroids_index)
centroids = NewCentroids
plt.scatter(centroids[:,0],centroids[:,1], overlap[i+4] , marker='x')
#time.sleep(5)
78/259:
def calMeans(X, centroids_index):
    centroids_mean  =np.array([])
    for i in range(len(centroids_index)):
        _index =  [index for index, value in enumerate(rank) if value == i]
        if(len(_index)>0):
            centroids_mean.append( sum(X[_index])/len(_index) )
            plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i+4] )
    
    return np.vstack(centroids_mean)
78/260:
X = mat1['X']
centroids = initial_centroids
78/261:
centroids_index = runkMeans(X, centroids)
NewCentroids = calMeans(X,centroids_index)
centroids = NewCentroids
plt.scatter(centroids[:,0],centroids[:,1], overlap[i+4] , marker='x')
#time.sleep(5)
78/262:
def calMeans(X, centroids_index):
    centroids_mean  =np.array([])
    for i in range(len(centroids_index)):
        _index =  [index for index, value in enumerate(rank) if value == i]
        if(len(_index)>0):
            #centroids_mean.append( sum(X[_index])/len(_index) 
            centroids_mean.append( 1)
            plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i+4] )
    
    return np.vstack(centroids_mean)
78/263:
X = mat1['X']
centroids = initial_centroids
78/264:
centroids_index = runkMeans(X, centroids)
NewCentroids = calMeans(X,centroids_index)
centroids = NewCentroids
plt.scatter(centroids[:,0],centroids[:,1], overlap[i+4] , marker='x')
#time.sleep(5)
78/265:
def calMeans(X, centroids_index):
    centroids_mean  = []
    for i in range(len(centroids_index)):
        _index =  [index for index, value in enumerate(rank) if value == i]
        if(len(_index)>0):
            #centroids_mean.append( sum(X[_index])/len(_index) 
            centroids_mean.append( sum(X[_index])/len(_index) )
            plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i+4] )
    
    return np.vstack(centroids_mean)
78/266:
X = mat1['X']
centroids = initial_centroids
78/267:
centroids_index = runkMeans(X, centroids)
NewCentroids = calMeans(X,centroids_index)
centroids = NewCentroids
plt.scatter(centroids[:,0],centroids[:,1], overlap[i+4] , marker='x')
#time.sleep(5)
78/268:
centroids_index = runkMeans(X, centroids)
NewCentroids = calMeans(X,centroids_index)
centroids = NewCentroids
for  i in range(len(centroids))
    plt.scatter(centroids[i,0],centroids[i,1], overlap[i+4] , marker='x')
#time.sleep(5)
78/269:
centroids_index = runkMeans(X, centroids)
NewCentroids = calMeans(X,centroids_index)
centroids = NewCentroids
for  i in range(len(centroids)):
    plt.scatter(centroids[i,0],centroids[i,1], overlap[i+4] , marker='x')
#time.sleep(5)
78/270: centroids
78/271: centroids[0:1]
78/272: centroids[0][1]
78/273: centroids[0][2]
78/274: centroids[0][1]
78/275: centroids[0]
78/276:
centroids_index = runkMeans(X, centroids)
NewCentroids = calMeans(X,centroids_index)
centroids = NewCentroids
for  i in range(len(centroids)):
    plt.scatter(centroids[i][0],centroids[i][1], overlap[i+4] , marker='x')
#time.sleep(5)
78/277: centroids[0][0]
78/278:
centroids_index = runkMeans(X, centroids)
NewCentroids = calMeans(X,centroids_index)
centroids = NewCentroids
for  i in range(len(centroids)):
    plt.scatter(centroids[i][0],centroids[i][1], color =overlap[i+4] , marker='x')
#time.sleep(5)
78/279:
centroids_index = runkMeans(X, centroids)
NewCentroids = calMeans(X,centroids_index)
centroids = NewCentroids
for  i in range(len(centroids)):
    plt.scatter(centroids[i][0],centroids[i][1], color =overlap[i+4] , marker='x')
78/280:
centroids_index = runkMeans(X, centroids)
NewCentroids = calMeans(X,centroids_index)
centroids = NewCentroids
for  i in range(len(centroids)):
    plt.scatter(centroids[i][0],centroids[i][1], color =overlap[i+4] , marker='x')
78/281:
centroids_index = runkMeans(X, centroids)
NewCentroids = calMeans(X,centroids_index)
centroids = NewCentroids
for  i in range(len(centroids)):
    plt.scatter(centroids[i][0],centroids[i][1], color =overlap[i+4] , marker='x')
78/282:
centroids_index = runkMeans(X, centroids)
NewCentroids = calMeans(X,centroids_index)
centroids = NewCentroids
for  i in range(len(centroids)):
    plt.scatter(centroids[i][0],centroids[i][1], color =overlap[i+4] , marker='x')
78/283:
for n in range(10):
    centroids_index = runkMeans(X, centroids)
    NewCentroids = calMeans(X,centroids_index)
    centroids = NewCentroids
    for  i in range(len(centroids)):
        plt.scatter(centroids[i][0],centroids[i][1], color =overlap[i+4] , marker='x')
78/284:
import matplotlib.pyplot as plt
import matplotlib._color_data as mcd
import seaborn as sns
sns.set_theme(style="darkgrid")

import numpy as np
import random
import statistics 
import time
78/285:
for n in range(10):
    centroids_index = runkMeans(X, centroids)
    NewCentroids = calMeans(X,centroids_index)
    centroids = NewCentroids
    for  i in range(len(centroids)):
        plt.scatter(centroids[i][0],centroids[i][1], color =overlap[i+4] , marker='x')
time.sleep(1)
78/286:
X = mat1['X']
centroids = initial_centroids
78/287:
k=3
initial_centroids = []
for i in range(3):
    initial_centroids.append([
        random.uniform(mat1['X'][:,0].min(), mat1['X'][:,0].max()),
        random.uniform(mat1['X'][:,1].min(), mat1['X'][:,1].max())])
    
initial_centroids = np.array(initial_centroids)

X = mat1['X']
centroids = initial_centroids
78/288:
k=3
initial_centroids = []
for i in range(3):
    initial_centroids.append([
        random.uniform(mat1['X'][:,0].min(), mat1['X'][:,0].max()),
        random.uniform(mat1['X'][:,1].min(), mat1['X'][:,1].max())])
    
initial_centroids = np.array(initial_centroids)



X = mat1['X']
centroids = initial_centroids

plt.scatter(mat1['X'][:,0],mat1['X'][:,1])
plt.scatter(initial_centroids[:,0],initial_centroids[:,1], color=['red','green','orange'], marker='x')
78/289:
k=3
initial_centroids = []
for i in range(3):
    initial_centroids.append([
        random.uniform(mat1['X'][:,0].min(), mat1['X'][:,0].max()),
        random.uniform(mat1['X'][:,1].min(), mat1['X'][:,1].max())])
    
initial_centroids = np.array(initial_centroids)



X = mat1['X']
centroids = initial_centroids

plt.scatter(mat1['X'][:,0],mat1['X'][:,1])
plt.scatter(initial_centroids[:,0],initial_centroids[:,1], color=['red','green','orange'], marker='x')
78/290:
k=3
initial_centroids = []
for i in range(3):
    initial_centroids.append([
        random.uniform(mat1['X'][:,0].min(), mat1['X'][:,0].max()),
        random.uniform(mat1['X'][:,1].min(), mat1['X'][:,1].max())])
    
initial_centroids = np.array(initial_centroids)



X = mat1['X']
centroids = initial_centroids

plt.scatter(mat1['X'][:,0],mat1['X'][:,1])
plt.scatter(initial_centroids[:,0],initial_centroids[:,1], color=['red','green','orange'], marker='x')
78/291:
for n in range(10):
    centroids_index = runkMeans(X, centroids)
    NewCentroids = calMeans(X,centroids_index)
    centroids = NewCentroids
    for  i in range(len(centroids)):
        plt.scatter(centroids[i][0],centroids[i][1], color =overlap[i+4] , marker='x')
    time.sleep(1)
78/292:
for n in range(10):
    centroids_index = runkMeans(X, centroids)
    NewCentroids = calMeans(X,centroids_index)
    centroids = NewCentroids
    for  i in range(len(centroids)):
        plt.scatter(centroids[i][0],centroids[i][1], color =overlap[i+4] , marker='x')
   plt.canvas.draw_idle()
   plt.canvas.start_event_loop(interval)
78/294:
k=3
initial_centroids = []
for i in range(3):
    initial_centroids.append([
        random.uniform(mat1['X'][:,0].min(), mat1['X'][:,0].max()),
        random.uniform(mat1['X'][:,1].min(), mat1['X'][:,1].max())])
    
initial_centroids = np.array(initial_centroids)



X = mat1['X']
centroids = initial_centroids

plt.scatter(mat1['X'][:,0],mat1['X'][:,1])
plt.scatter(initial_centroids[:,0],initial_centroids[:,1], color=['red','green','orange'], marker='x')
78/295:
centroids_index = runkMeans(X, centroids)
NewCentroids = calMeans(X,centroids_index)
centroids = NewCentroids
for  i in range(len(centroids)):
    plt.scatter(centroids[i][0],centroids[i][1], color =overlap[i+4] , marker='x')
78/296:
centroids_index = runkMeans(X, centroids)
NewCentroids = calMeans(X,centroids_index)
centroids = NewCentroids
for  i in range(len(centroids)):
    plt.scatter(centroids[i][0],centroids[i][1], color =overlap[i+4] , marker='x')
78/297:
centroids_index = runkMeans(X, centroids)
NewCentroids = calMeans(X,centroids_index)
centroids = NewCentroids
for  i in range(len(centroids)):
    plt.scatter(centroids[i][0],centroids[i][1], color =overlap[i+4] , marker='x')
78/298:
centroids_index = runkMeans(X, centroids)
NewCentroids = calMeans(X,centroids_index)
centroids = NewCentroids
for  i in range(len(centroids)):
    plt.scatter(centroids[i][0],centroids[i][1], color =overlap[i+4] , marker='x')
78/299:
k=3
initial_centroids = []
for i in range(3):
    initial_centroids.append([
        random.uniform(mat1['X'][:,0].min(), mat1['X'][:,0].max()),
        random.uniform(mat1['X'][:,1].min(), mat1['X'][:,1].max())])
    
initial_centroids = np.array(initial_centroids)



X = mat1['X']
centroids = initial_centroids

plt.scatter(mat1['X'][:,0],mat1['X'][:,1])
plt.scatter(initial_centroids[:,0],initial_centroids[:,1], color=['red','green','orange'], marker='x')
78/300:
k=3
initial_centroids = []
for i in range(3):
    initial_centroids.append([
        random.uniform(mat1['X'][:,0].min(), mat1['X'][:,0].max()),
        random.uniform(mat1['X'][:,1].min(), mat1['X'][:,1].max())])
    
initial_centroids = np.array(initial_centroids)



X = mat1['X']
centroids = initial_centroids
print(centroids)
plt.scatter(mat1['X'][:,0],mat1['X'][:,1])
plt.scatter(initial_centroids[:,0],initial_centroids[:,1], color=['red','green','orange'], marker='x')
78/301:
centroids_index = runkMeans(X, centroids)
NewCentroids = calMeans(X,centroids_index)
centroids = NewCentroids
print(NewCentroids)
for  i in range(len(centroids)):
    plt.scatter(centroids[i][0],centroids[i][1], color =overlap[i+4] , marker='x')
78/302:
centroids_index = runkMeans(X, centroids)
NewCentroids = calMeans(X,centroids_index)
centroids = NewCentroids
for  i in range(len(centroids)):
    plt.scatter(centroids[i][0],centroids[i][1], color =overlap[i+4] , marker='x')
78/303:
k=3
initial_centroids = []
for i in range(3):
    initial_centroids.append([
        random.uniform(mat1['X'][:,0].min(), mat1['X'][:,0].max()),
        random.uniform(mat1['X'][:,1].min(), mat1['X'][:,1].max())])
    
initial_centroids = np.array(initial_centroids)



X = mat1['X']
centroids = initial_centroids
print(centroids)
plt.scatter(mat1['X'][:,0],mat1['X'][:,1])
plt.scatter(initial_centroids[:,0],initial_centroids[:,1], color=['red','green','orange'], marker='x')
78/304:
centroids_index = runkMeans(X, centroids)
NewCentroids = calMeans(X,centroids_index)
centroids = NewCentroids
print(NewCentroids)
for  i in range(len(centroids)):
    plt.scatter(centroids[i][0],centroids[i][1], color =overlap[i+4] , marker='x')
78/305:
centroids_index = runkMeans(X, centroids)
NewCentroids = calMeans(X,centroids_index)
centroids = NewCentroids
print(NewCentroids)
for  i in range(len(centroids)):
    plt.scatter(centroids[i][0],centroids[i][1], color =overlap[i+4] , marker='x')
78/306:
k=3
initial_centroids = []
for i in range(3):
    initial_centroids.append([
        random.uniform(mat1['X'][:,0].min(), mat1['X'][:,0].max()),
        random.uniform(mat1['X'][:,1].min(), mat1['X'][:,1].max())])
    
initial_centroids = np.array(initial_centroids)



X = mat1['X']
centroids = initial_centroids
print(centroids)
plt.scatter(mat1['X'][:,0],mat1['X'][:,1])
plt.scatter(initial_centroids[:,0],initial_centroids[:,1], color=['red','green','orange'], marker='x')
78/307:
centroids_index = runkMeans(X, centroids)
NewCentroids = calMeans(X,centroids_index)
centroids = NewCentroids
print(NewCentroids)
for  i in range(len(centroids)):
    plt.scatter(centroids[i][0],centroids[i][1], color =overlap[i+4] , marker='x')
78/308:
centroids_index = runkMeans(X, centroids)
NewCentroids = calMeans(X,centroids_index)
centroids = NewCentroids
print(NewCentroids)
for  i in range(len(centroids)):
    plt.scatter(centroids[i][0],centroids[i][1], color =overlap[i+4] , marker='x')
78/309:
k=2
initial_centroids = []
for i in range(k):
    initial_centroids.append([
        random.uniform(mat1['X'][:,0].min(), mat1['X'][:,0].max()),
        random.uniform(mat1['X'][:,1].min(), mat1['X'][:,1].max())])
    
initial_centroids = np.array(initial_centroids)



X = mat1['X']
centroids = initial_centroids
print(centroids)
plt.scatter(mat1['X'][:,0],mat1['X'][:,1])
plt.scatter(initial_centroids[:,0],initial_centroids[:,1], color=['red','green','orange'], marker='x')
78/310:
k=2
initial_centroids = []
for i in range(k):
    initial_centroids.append([
        random.uniform(mat1['X'][:,0].min(), mat1['X'][:,0].max()),
        random.uniform(mat1['X'][:,1].min(), mat1['X'][:,1].max())])
    
initial_centroids = np.array(initial_centroids)



X = mat1['X']
centroids = initial_centroids
print(centroids)
plt.scatter(mat1['X'][:,0],mat1['X'][:,1])
for  i in range(len(centroids)):
    plt.scatter(initial_centroids[:,0],initial_centroids[:,1],  color =overlap[i+4] , marker='x')
78/311:
k=2
initial_centroids = []
for i in range(k):
    initial_centroids.append([
        random.uniform(mat1['X'][:,0].min(), mat1['X'][:,0].max()),
        random.uniform(mat1['X'][:,1].min(), mat1['X'][:,1].max())])
    
initial_centroids = np.array(initial_centroids)



X = mat1['X']
centroids = initial_centroids
print(centroids)
plt.scatter(mat1['X'][:,0],mat1['X'][:,1])
for  i in range(len(initial_centroids)):
    plt.scatter(initial_centroids[:,0],initial_centroids[:,1],  color =overlap[i+4] , marker='x')
78/312:
k=2
initial_centroids = []
for i in range(k):
    initial_centroids.append([
        random.uniform(mat1['X'][:,0].min(), mat1['X'][:,0].max()),
        random.uniform(mat1['X'][:,1].min(), mat1['X'][:,1].max())])
    
initial_centroids = np.array(initial_centroids)



X = mat1['X']
centroids = initial_centroids
print(centroids)
plt.scatter(mat1['X'][:,0],mat1['X'][:,1])
for  i in range(len(initial_centroids)):
    plt.scatter(initial_centroids[i,0],initial_centroids[i,1],  color =overlap[i+4] , marker='x')
78/313:
centroids_index = runkMeans(X, centroids)
NewCentroids = calMeans(X,centroids_index)
centroids = NewCentroids
print(NewCentroids)
for  i in range(len(centroids)):
    plt.scatter(centroids[i][0],centroids[i][1], color =overlap[i+4] , marker='x')
78/314:
centroids_index = runkMeans(X, centroids)
NewCentroids = calMeans(X,centroids_index)
centroids = NewCentroids
print(NewCentroids)
for  i in range(len(centroids)):
    plt.scatter(centroids[i][0],centroids[i][1], color =overlap[i+4] , marker='x')
78/315: centroids
78/316:
k=2
initial_centroids = []
for i in range(k):
    initial_centroids.append([
        random.uniform(mat1['X'][:,0].min(), mat1['X'][:,0].max()),
        random.uniform(mat1['X'][:,1].min(), mat1['X'][:,1].max())])
    
initial_centroids = np.array(initial_centroids)



X = mat1['X']
centroids = initial_centroids
print(centroids)
plt.scatter(mat1['X'][:,0],mat1['X'][:,1])
for  i in range(len(initial_centroids)):
    plt.scatter(initial_centroids[i,0],initial_centroids[i,1],  color =overlap[i+4] , marker='x')
78/317: centroids
78/318:
centroids_index = runkMeans(X, centroids)
NewCentroids = calMeans(X,centroids_index)
centroids = NewCentroids
print(NewCentroids)
for  i in range(len(centroids)):
    plt.scatter(centroids[i][0],centroids[i][1], color =overlap[i+4] , marker='x')
78/319: centroids
78/320:
k=2
initial_centroids = []
for i in range(k):
    initial_centroids.append([
        random.uniform(mat1['X'][:,0].min(), mat1['X'][:,0].max()),
        random.uniform(mat1['X'][:,1].min(), mat1['X'][:,1].max())])
    
initial_centroids = np.array(initial_centroids)



X = mat1['X']
centroids = initial_centroids
print(centroids)
plt.scatter(mat1['X'][:,0],mat1['X'][:,1])
for  i in range(len(initial_centroids)):
    plt.scatter(initial_centroids[i,0],initial_centroids[i,1],  color =overlap[i+4] , marker='x')
78/321:
NewCentroids=[]
centroids_index = runkMeans(X, centroids)
NewCentroids = calMeans(X,centroids_index)
centroids = NewCentroids
print(NewCentroids)
for  i in range(len(centroids)):
    plt.scatter(centroids[i][0],centroids[i][1], color =overlap[i+4] , marker='x')
78/322:
NewCentroids=[]
centroids_index = runkMeans(X, centroids)
print(centroids_index)
NewCentroids = calMeans(X,centroids_index)
centroids = NewCentroids
print(NewCentroids)
for  i in range(len(centroids)):
    plt.scatter(centroids[i][0],centroids[i][1], color =overlap[i+4] , marker='x')
78/323:
centroids_index = runkMeans(X, centroids)
NewCentroids = calMeans(X,centroids_index)
centroids = NewCentroids
print(NewCentroids)
for  i in range(len(centroids)):
    plt.scatter(centroids[i][0],centroids[i][1], color =overlap[i+4] , marker='x')
78/324:
def runkMeans(X, centroids):
    centroids_index = []
    for i in range(len(X)):
        sumSqrt=[]
        for k in range(len(centroids)):
            sumSqrt.append( np.sqrt(sum((X[i] - centroids[k])**2)) )
            
        centroids_index.append(sumSqrt.index(min(sumSqrt)))
        
    return centroids_index
78/325:
k=2
initial_centroids = []
for i in range(k):
    initial_centroids.append([
        random.uniform(mat1['X'][:,0].min(), mat1['X'][:,0].max()),
        random.uniform(mat1['X'][:,1].min(), mat1['X'][:,1].max())])
    
initial_centroids = np.array(initial_centroids)



X = mat1['X']
centroids = initial_centroids
print(centroids)
plt.scatter(mat1['X'][:,0],mat1['X'][:,1])
for  i in range(len(initial_centroids)):
    plt.scatter(initial_centroids[i,0],initial_centroids[i,1],  color =overlap[i+4] , marker='x')
78/326: runkMeans(X, centroids)
78/327:
centroids_index = runkMeans(X, centroids)
centroids_index
78/328:
centroids_index = runkMeans(X, centroids)
NewCentroids = calMeans(X,centroids_index)
78/329:
centroids_index = runkMeans(X, centroids)
NewCentroids = calMeans(X,centroids_index)
centroids_index
78/330:
centroids_index = runkMeans(X, centroids)
NewCentroids = calMeans(X,centroids_index)
78/331:
centroids_index = runkMeans(X, centroids)
NewCentroids = calMeans(X,centroids_index)
78/332:
centroids_index = runkMeans(X, centroids)
NewCentroids = calMeans(X,centroids_index)
NewCentroids
78/333:
centroids_index = runkMeans(X, centroids)
centroids_index
NewCentroids = calMeans(X,centroids_index)
NewCentroids
78/334:
centroids_index = runkMeans(X, centroids)
print(centroids_index)
NewCentroids = calMeans(X,centroids_index)
NewCentroids
78/335:
def calMeans(X, centroids_index):
    centroids_mean  = []
    prnt(centroids_index)
    for i in range(len(centroids_index)):
        prnt(i)
        _index =  [index for index, value in enumerate(rank) if value == i]
        if(len(_index)>0):
            #centroids_mean.append( sum(X[_index])/len(_index) 
            centroids_mean.append( sum(X[_index])/len(_index) )
            plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i+4] )
    
    return np.vstack(centroids_mean)
78/336: NewCentroids = calMeans(X,centroids_index)
78/337:
def calMeans(X, centroids_index):
    centroids_mean  = []
    print(centroids_index)
    for i in range(len(centroids_index)):
        print(i)
        _index =  [index for index, value in enumerate(rank) if value == i]
        if(len(_index)>0):
            #centroids_mean.append( sum(X[_index])/len(_index) 
            centroids_mean.append( sum(X[_index])/len(_index) )
            plt.scatter(X[_index][:,0],X[_index][:,1], color = overlap[i+4] )
    
    return np.vstack(centroids_mean)
78/338: NewCentroids = calMeans(X,centroids_index)
80/1:
import datetime
from datetime import datetime as dt
import numpy as np
from BitkubTrade import Bitkub
import time 
# API info
API_HOST = 'https://api.bitkub.com'
API_KEY = '343f340ba1aafd4a4d056801c791f14d'
API_SECRET = b'4fd33427a5d4dfddb93ce38251c4d8e5'
81/1:
import datetime
from datetime import datetime as dt
import numpy as np
from BitkubTrade import Bitkub
import time 
# API info
API_HOST = 'https://api.bitkub.com'
API_KEY = '343f340ba1aafd4a4d056801c791f14d'
API_SECRET = b'4fd33427a5d4dfddb93ce38251c4d8e5'
81/2:
def initialization():  
    print("----------- Initialize -----------")
    #--------------------------variable-----------------------------
    #ProductSetting
    global _symbol, _symbolSplit ,_rebalance
    _symbol = 'THB_XRP'  # THB_XRP
    _symbolSplit =  _symbol.split("_")
    _rebalance = 0.10#0.1 = 10% min 20 THB
    #SystemSetting
    global _system
    _system = True

    #API
    global bitkubAPI
    bitkubAPI=Bitkub(API_HOST,API_KEY,API_SECRET)
81/3:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    baseSymbol  = _symbolSplit[0]
    secSymbol   = _symbolSplit[1]
    secSymConvert = _symbolSplit[1]+"convert"

    balance = { baseSymbol      :   bitkubAPI.balance()[baseSymbol]['available'],
                secSymbol       :   bitkubAPI.balance()[secSymbol]['available'],
                secSymConvert   :   bitkubAPI.balance()[secSymbol]['available']*rateAsk
            }
            
    #reblanceCondition
    change = ( balance[secSymConvert] / balance[baseSymbol] )-1
    print(change)
    if(change > _rebalance):                            # sec > THB ,_Rebalance%
        amtBase = (change*balance[secSymConvert])/2      #จำนวณเงิน sec ที่ต้อง Reblance หน่วย base
        amtSec= amtBase//rateAsk                       #จำนวณเงิน sec ที่ต้อง Reblance หน่วย sec
        if(amtBase > 20):
            res = bitkubAPI.placeOrder(_symbol,'buy', amtSec, rateAsk, 'market')
            print(res)
            '''
            if(res):
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'buy{baseSymbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            '''
        
    elif(change < -_rebalance):                        # sec < THB ,_Rebalance%
        amtBase = (abs(change)*balance[baseSymbol])//2       #จำนวณเงิน base ที่ต้อง Reblance หน่วย base 
        if(amtBase > 20):
            res = bitkubAPI.placeOrder(_symbol, 'sell', amtBase, rateBid, 'market')
            print(res)
            '''
            if(res):
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'sell{secSymbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            '''

    print(f'{baseSymbol}:{round(balance[baseSymbol], 2)} {secSymConvert}:{round(balance[secSymConvert], 2)}   {datetime.datetime.fromtimestamp(tsAsk)}')
81/4:
import datetime
from datetime import datetime as dt
import numpy as np
from BitkubTrade import Bitkub
import time 
# API info
API_HOST = 'https://api.bitkub.com'
API_KEY = '343f340ba1aafd4a4d056801c791f14d'
API_SECRET = b'4fd33427a5d4dfddb93ce38251c4d8e5'
81/5:
def initialization():  
    print("----------- Initialize -----------")
    #--------------------------variable-----------------------------
    #ProductSetting
    global _symbol, _symbolSplit ,_rebalance
    _symbol = 'THB_XRP'  # THB_XRP
    _symbolSplit =  _symbol.split("_")
    _rebalance = 0.10#0.1 = 10% min 20 THB
    #SystemSetting
    global _system
    _system = True

    #API
    global bitkubAPI
    bitkubAPI=Bitkub(API_HOST,API_KEY,API_SECRET)
81/6:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    baseSymbol  = _symbolSplit[0]
    secSymbol   = _symbolSplit[1]
    secSymConvert = _symbolSplit[1]+"convert"

    balance = { baseSymbol      :   bitkubAPI.balance()[baseSymbol]['available'],
                secSymbol       :   bitkubAPI.balance()[secSymbol]['available'],
                secSymConvert   :   bitkubAPI.balance()[secSymbol]['available']*rateAsk
            }
            
    #reblanceCondition
    change = ( balance[secSymConvert] / balance[baseSymbol] )-1
    print(change)
    if(change > _rebalance):                            # sec > THB ,_Rebalance%
        amtBase = (change*balance[secSymConvert])/2      #จำนวณเงิน sec ที่ต้อง Reblance หน่วย base
        amtSec= amtBase//rateAsk                       #จำนวณเงิน sec ที่ต้อง Reblance หน่วย sec
        if(amtBase > 20):
            res =  'buy'#bitkubAPI.placeOrder(_symbol,'buy', amtSec, rateAsk, 'market')
            print(res)
            '''
            if(res):
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'buy{baseSymbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            '''
        
    elif(change < -_rebalance):                        # sec < THB ,_Rebalance%
        amtBase = (abs(change)*balance[baseSymbol])//2       #จำนวณเงิน base ที่ต้อง Reblance หน่วย base 
        if(amtBase > 20):
            res = 'sell'#bitkubAPI.placeOrder(_symbol, 'sell', amtBase, rateBid, 'market')
            print(res)
            '''
            if(res):
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'sell{secSymbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            '''

    print(f'{baseSymbol}:{round(balance[baseSymbol], 2)} {secSymConvert}:{round(balance[secSymConvert], 2)}   {datetime.datetime.fromtimestamp(tsAsk)}')
81/7:
initialization()
main()
81/8:
initialization()
main()
81/9:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    baseSymbol  = _symbolSplit[0]
    secSymbol   = _symbolSplit[1]
    secSymConvert = _symbolSplit[1]+"convert"

    balance = { baseSymbol      :   bitkubAPI.balance()[baseSymbol]['available'],
                secSymbol       :   bitkubAPI.balance()[secSymbol]['available'],
                secSymConvert   :   bitkubAPI.balance()[secSymbol]['available']*rateAsk
            }
    
    print(f'{baseSymbol}:{round(balance[baseSymbol], 2)} {secSymConvert}:{round(balance[secSymConvert], 2)}   {datetime.datetime.fromtimestamp(tsAsk)}')
    
    #reblanceCondition
    change = ( balance[secSymConvert] / balance[baseSymbol] )-1
    print(change)
    if(change > _rebalance):                            # sec > THB ,_Rebalance%
        amtBase = (change*balance[secSymConvert])/2      #จำนวณเงิน sec ที่ต้อง Reblance หน่วย base
        amtSec= amtBase//rateAsk                       #จำนวณเงิน sec ที่ต้อง Reblance หน่วย sec
        if(amtBase > 20):
            res = bitkubAPI.placeOrder(_symbol,'buy', amtSec, rateAsk, 'market')
            print(res)
            '''
            if(res):
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'buy{baseSymbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            '''
        
    elif(change < -_rebalance):                        # sec < THB ,_Rebalance%
        amtBase = (abs(change)*balance[baseSymbol])//2       #จำนวณเงิน base ที่ต้อง Reblance หน่วย base 
        if(amtBase > 20):
            res = bitkubAPI.placeOrder(_symbol, 'sell', amtBase, rateBid, 'market')
            print(res)
            '''
            if(res):
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'sell{secSymbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            '''
81/10:
initialization()
main()
81/11: _symbol
81/12: bitkubAPI.getSymbolsInfo()
81/13:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    baseSymbol  = _symbolSplit[0]
    secSymbol   = _symbolSplit[1]
    secSymConvert = _symbolSplit[1]+"convert"

    balance = { baseSymbol      :   bitkubAPI.balance()[baseSymbol]['available'],
                secSymbol       :   bitkubAPI.balance()[secSymbol]['available'],
                secSymConvert   :   bitkubAPI.balance()[secSymbol]['available']*rateAsk
            }
    
    print(f'{baseSymbol}:{round(balance[baseSymbol], 2)} {secSymConvert}:{round(balance[secSymConvert], 2)}   {datetime.datetime.fromtimestamp(tsAsk)}')
    
    #reblanceCondition
    change = ( balance[secSymConvert] / balance[baseSymbol] )-1
    print(change)
    if(change > _rebalance):                            # sec > THB ,_Rebalance%
        amtBase = (change*balance[secSymConvert])/2      #จำนวณเงิน sec ที่ต้อง Reblance หน่วย base
        amtSec= amtBase//rateAsk                       #จำนวณเงิน sec ที่ต้อง Reblance หน่วย sec
        res =f'{amtSec}, {rateAsk}'
        if(amtBase > 20):
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtSec, rateAsk, 'market')
            if(res[''error'']!=True):
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'buy{baseSymbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                print(res)

        
    elif(change < -_rebalance):                        # sec < THB ,_Rebalance%
        amtBase = (abs(change)*balance[baseSymbol])//2       #จำนวณเงิน base ที่ต้อง Reblance หน่วย base 
        res =f'{amtSec}, {rateAsk}'
        if(amtBase > 20):
            #res = bitkubAPI.placeOrder(_symbol, 'sell', amtBase, rateBid, 'market')
            if(res[''error'']!=True):
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'sell{secSymbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                print(res)
81/14:
initialization()
main()
81/15:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    baseSymbol  = _symbolSplit[0]
    secSymbol   = _symbolSplit[1]
    secSymConvert = _symbolSplit[1]+"convert"

    balance = { baseSymbol      :   bitkubAPI.balance()[baseSymbol]['available'],
                secSymbol       :   bitkubAPI.balance()[secSymbol]['available'],
                secSymConvert   :   bitkubAPI.balance()[secSymbol]['available']*rateAsk
            }
    
    print(f'{baseSymbol}:{round(balance[baseSymbol], 2)} {secSymConvert}:{round(balance[secSymConvert], 2)}   {datetime.datetime.fromtimestamp(tsAsk)}')
    
    #reblanceCondition
    change = ( balance[secSymConvert] / balance[baseSymbol] )-1
    print(change)
    if(change > _rebalance):                            # sec > THB ,_Rebalance%
        amtBase = (change*balance[secSymConvert])/2      #จำนวณเงิน sec ที่ต้อง Reblance หน่วย base
        amtSec= amtBase//rateAsk                       #จำนวณเงิน sec ที่ต้อง Reblance หน่วย sec
        res =f'{amtSec}, {rateAsk}'
        if(amtBase > 20):
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtSec, rateAsk, 'market')
            if(res['error']!=True):
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'buy{baseSymbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                print(res)

        
    elif(change < -_rebalance):                        # sec < THB ,_Rebalance%
        amtBase = (abs(change)*balance[baseSymbol])//2       #จำนวณเงิน base ที่ต้อง Reblance หน่วย base 
        res =f'{amtSec}, {rateAsk}'
        if(amtBase > 20):
            #res = bitkubAPI.placeOrder(_symbol, 'sell', amtBase, rateBid, 'market')
            if(res['error']!=True):
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'sell{secSymbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                print(res)
81/16:
initialization()
main()
81/17:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    baseSymbol  = _symbolSplit[0]
    secSymbol   = _symbolSplit[1]
    secSymConvert = _symbolSplit[1]+"convert"

    balance = { baseSymbol      :   bitkubAPI.balance()[baseSymbol]['available'],
                secSymbol       :   bitkubAPI.balance()[secSymbol]['available'],
                secSymConvert   :   bitkubAPI.balance()[secSymbol]['available']*rateAsk
            }
    
    print(f'{baseSymbol}:{round(balance[baseSymbol], 2)} {secSymConvert}:{round(balance[secSymConvert], 2)}   {datetime.datetime.fromtimestamp(tsAsk)}')
    
    #reblanceCondition
    change = ( balance[secSymConvert] / balance[baseSymbol] )-1
    print(change)
    if(change > _rebalance):                            # sec > THB ,_Rebalance%
        amtBase = (change*balance[secSymConvert])/2      #จำนวณเงิน sec ที่ต้อง Reblance หน่วย base
        amtSec= amtBase//rateAsk                       #จำนวณเงิน sec ที่ต้อง Reblance หน่วย sec
        res ={'1':amtSec, '2':rateAsk}
        print(res)
        if(amtBase > 20):
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtSec, rateAsk, 'market')
            if(res['error']!=True):
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'buy{baseSymbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                print(res)

        
    elif(change < -_rebalance):                        # sec < THB ,_Rebalance%
        amtBase = (abs(change)*balance[baseSymbol])//2       #จำนวณเงิน base ที่ต้อง Reblance หน่วย base 
        res ={'1':amtSec, '2':rateAsk}
        print(res)
        if(amtBase > 20):
            #res = bitkubAPI.placeOrder(_symbol, 'sell', amtBase, rateBid, 'market')
            if(res['error']!=True):
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'sell{secSymbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                print(res)
81/18:
initialization()
main()
81/19:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    baseSymbol  = _symbolSplit[0]
    secSymbol   = _symbolSplit[1]
    secSymConvert = _symbolSplit[1]+"convert"

    balance = { baseSymbol      :   bitkubAPI.balance()[baseSymbol]['available'],
                secSymbol       :   bitkubAPI.balance()[secSymbol]['available'],
                secSymConvert   :   bitkubAPI.balance()[secSymbol]['available']*rateAsk
            }
    
    print(f'{baseSymbol}:{round(balance[baseSymbol], 2)} {secSymConvert}:{round(balance[secSymConvert], 2)}   {datetime.datetime.fromtimestamp(tsAsk)}')
    
    #reblanceCondition
    change = ( balance[secSymConvert] / balance[baseSymbol] )-1
    print(change)
    if(change > _rebalance):                            # sec > THB ,_Rebalance%
        amtBase = (change*balance[secSymConvert])/2      #จำนวณเงิน sec ที่ต้อง Reblance หน่วย base
        amtSec= amtBase//rateAsk                       #จำนวณเงิน sec ที่ต้อง Reblance หน่วย sec
        res ={'error':0, 'amtSec':amtSec, 'amtBase':amtBase, 'rateAsk':rateAsk}
        print(res)
        if(amtBase > 20):
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtSec, rateAsk, 'market')
            if(res['error']==0):
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'buy{baseSymbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                print(res['result'])

        
    elif(change < -_rebalance):                        # sec < THB ,_Rebalance%
        amtBase = (abs(change)*balance[baseSymbol])//2       #จำนวณเงิน base ที่ต้อง Reblance หน่วย base 
        res ={'1':amtSec, '2':rateAsk}
        print(res)
        if(amtBase > 20):
            #res = bitkubAPI.placeOrder(_symbol, 'sell', amtBase, rateBid, 'market')
            if(res['error']!=True):
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'sell{secSymbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                 print(res['result'])
81/20:
initialization()
main()
82/1:
import datetime
from datetime import datetime as dt
import numpy as np
from BitkubTrade import Bitkub
import time 
# API info
API_HOST = 'https://api.bitkub.com'
API_KEY = '343f340ba1aafd4a4d056801c791f14d'
API_SECRET = b'4fd33427a5d4dfddb93ce38251c4d8e5'
82/2:
def initialization():  
    print("----------- Initialize -----------")
    #--------------------------variable-----------------------------
    #ProductSetting
    global _symbol, _symbolSplit ,_rebalance
    _symbol = 'THB_XRP'  # THB_XRP
    _symbolSplit =  _symbol.split("_")
    _rebalance = 0.10#0.1 = 10% min 20 THB
    #SystemSetting
    global _system
    _system = True

    #API
    global bitkubAPI
    bitkubAPI=Bitkub(API_HOST,API_KEY,API_SECRET)
82/3:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    baseSymbol  = _symbolSplit[0]
    secSymbol   = _symbolSplit[1]
    secSymConvert = _symbolSplit[1]+"convert"

    balance = { baseSymbol      :   bitkubAPI.balance()[baseSymbol]['available'],
                secSymbol       :   bitkubAPI.balance()[secSymbol]['available'],
                secSymConvert   :   bitkubAPI.balance()[secSymbol]['available']*rateAsk
            }
    
    print(f'{baseSymbol}:{round(balance[baseSymbol], 2)} {secSymConvert}:{round(balance[secSymConvert], 2)}   {datetime.datetime.fromtimestamp(tsAsk)}')
    
    #reblanceCondition
    change = ( balance[secSymConvert] / balance[baseSymbol] )-1
    print(f'secSymConvert : {balance[secSymConvert]}' )
    print(f'secSymConvert : {balance[baseSymbol]}' )
    print(change)
    if(change > _rebalance):                            # sec > THB ,_Rebalance%
        amtBase = (change*balance[secSymConvert])/2      #จำนวณเงิน sec ที่ต้อง Reblance หน่วย base
        amtSec= amtBase//rateAsk                       #จำนวณเงิน sec ที่ต้อง Reblance หน่วย sec
        res ={'error':0, 'amtSec':amtSec, 'amtBase':amtBase, 'rateAsk':rateAsk}
        print(res)
        if(amtBase > 20):
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtSec, rateAsk, 'market')
            if('error' not in res):
                res=res['result']
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'buy{baseSymbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                print(res)

        
    elif(change < -_rebalance):                        # sec < THB ,_Rebalance%
        amtBase = (abs(change)*balance[baseSymbol])//2       #จำนวณเงิน base ที่ต้อง Reblance หน่วย base 
        res ={'1':amtSec, '2':rateAsk}
        print(res)
        if(amtBase > 20):
            #res = bitkubAPI.placeOrder(_symbol, 'sell', amtBase, rateBid, 'market')
            if('error' not in res):
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'sell{secSymbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                 print(res['result'])
82/4:
initialization()
main()
82/5: 494.6232820878/89.37
82/6: 494.6232820878/89.37 -1
82/7: 100/50 -1
82/8: 100/50
82/9: 110/100
82/10: 110/100-1
82/11: 110/90-1
82/12: 110/89.37-1
82/13: 200/89.37-1
82/14: 300/89.37-1
82/15: 400/89.37-1
82/16: 494/89.37-1
82/17: 494.6232820878*4.52758196262728
82/18: 494-89.37/89.37-1
82/19: (494-89.37)/89.37
82/20: (494-89.37)
82/21: (494-89.37)/2
82/22: 494-202.315
82/23: 202.315+89.37
82/24: 494-89.37
82/25: 494/404.63
82/26: (494-89.37)
82/27: (494-89.37)/494
82/28: 494+89.37
82/29: (494-89.37)/494+89.37
82/30: (494-89.37)/(494+89.37)
82/31: (494-89.37)/((494+89.37)/2)
82/32: (494)/((494+89.37)/2)
82/33: ((494+89.37)/2)
82/34: 494*0.69
82/35: 494*(1.69-1)
82/36: 494-340
82/37: ((494+89.37)/2)
82/38: 494-291.685
82/39: ((494+89.37)/2)
82/40: (494)/291.685
82/41: 494/291.685
82/42: 110/100
82/43: 494 - (494*0.06936078303649484)
82/44:  (494*0.06936078303649484)
82/45: 494 - (494*0.06936078303649484)
82/46: 494-291.685
82/47: 494 / 100
82/48: 494 / 291.685
82/49: 291.685*1.6936078303649484
82/50: 494.08.6936078303649484
82/51: 494.0* .6936078303649484
82/52: 494.0-342.64226820028455
82/53: .6936078303649484/2
82/54: 494.0*0.3468039151824742
82/55: 494.0 -171.32113410014227
82/56: 291.685 +171.32113410014227
82/57: (494+89.37)/2
82/58: 494*0.69
82/59: 494*(0.69/2)
82/60: 89.37+170.42999999999998
82/61: 494+170.42999999999998
82/62: 494-170.42999999999998
82/63:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    baseSymbol  = _symbolSplit[0]
    secSymbol   = _symbolSplit[1]
    secSymConvert = _symbolSplit[1]+"convert"

    balance = { baseSymbol      :   bitkubAPI.balance()[baseSymbol]['available'],
                secSymbol       :   bitkubAPI.balance()[secSymbol]['available'],
                secSymConvert   :   bitkubAPI.balance()[secSymbol]['available']*rateAsk
            }
    
    
    
    #reblanceCondition
    totalAmt =balance[secSymConvert] + balance[baseSymbol]
    balanceAmt = totalAmt/2
    print(f'{baseSymbol}:{round(balance[baseSymbol], 2)} {secSymConvert}:{round(balance[secSymConvert], 2)} totalAmt:{totalAmt}   {datetime.datetime.fromtimestamp(tsAsk)}')
    
    if(balance[secSymConvert]/balanceAmt > _rebalance):                            
        amtRe =(balance[secSymConvert]-balanceAmt)/2 #re amtBase
        amtRe = amtRe/rateAsk#re amtSec
        res ={'error':0, 'amtSec':amtSec, 'amtBase':amtBase, 'amtRe':amtRe}
        print(res)
        if(amtBase > 20):
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            if('error' not in res):
                res=res['result']
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'buy{baseSymbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                print(res)

        
    elif(change < -_rebalance):                        # sec < THB ,_Rebalance%
        amtBase = (abs(change)*balance[baseSymbol])//2       #จำนวณเงิน base ที่ต้อง Reblance หน่วย base 
        res ={'1':amtSec, '2':rateAsk}
        print(res)
        if(amtBase > 20):
            #res = bitkubAPI.placeOrder(_symbol, 'sell', amtRe, rateBid, 'market')
            if('error' not in res):
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'sell{secSymbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                 print(res['result'])
82/64:
initialization()
main()
82/65:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    baseSymbol  = _symbolSplit[0]
    secSymbol   = _symbolSplit[1]
    secSymConvert = _symbolSplit[1]+"convert"

    balance = { baseSymbol      :   bitkubAPI.balance()[baseSymbol]['available'],
                secSymbol       :   bitkubAPI.balance()[secSymbol]['available'],
                secSymConvert   :   bitkubAPI.balance()[secSymbol]['available']*rateAsk
            }
    
    
    
    #reblanceCondition
    totalAmt =balance[secSymConvert] + balance[baseSymbol]
    balanceAmt = totalAmt/2
    print(f'{baseSymbol}:{round(balance[baseSymbol], 2)} {secSymConvert}:{round(balance[secSymConvert], 2)} totalAmt:{totalAmt}   {datetime.datetime.fromtimestamp(tsAsk)}')
    
    if(balance[secSymConvert]/balanceAmt > _rebalance):                            
        amtRe =(balance[secSymConvert]-balanceAmt)/2 #re amtBase
        amtRe = amtRe/rateAsk#re amtSec
        res ={'error':0, 'amtBase':amtBase, 'amtRe':amtRe}
        print(res)
        if(amtBase > 20):
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            if('error' not in res):
                res=res['result']
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'buy{baseSymbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                print(res)

        
    elif(change < -_rebalance):                        # sec < THB ,_Rebalance%
        amtBase = (abs(change)*balance[baseSymbol])//2       #จำนวณเงิน base ที่ต้อง Reblance หน่วย base 
        res ={'1':amtSec, '2':rateAsk}
        print(res)
        if(amtBase > 20):
            #res = bitkubAPI.placeOrder(_symbol, 'sell', amtRe, rateBid, 'market')
            if('error' not in res):
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'sell{secSymbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                 print(res['result'])
82/66:
initialization()
main()
82/67:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    baseSymbol  = _symbolSplit[0]
    secSymbol   = _symbolSplit[1]
    secSymConvert = _symbolSplit[1]+"convert"

    balance = { baseSymbol      :   bitkubAPI.balance()[baseSymbol]['available'],
                secSymbol       :   bitkubAPI.balance()[secSymbol]['available'],
                secSymConvert   :   bitkubAPI.balance()[secSymbol]['available']*rateAsk
            }
    
    
    
    #reblanceCondition
    totalAmt =balance[secSymConvert] + balance[baseSymbol]
    balanceAmt = totalAmt/2
    print(f'{baseSymbol}:{round(balance[baseSymbol], 2)} {secSymConvert}:{round(balance[secSymConvert], 2)} totalAmt:{totalAmt}   {datetime.datetime.fromtimestamp(tsAsk)}')
    
    if(balance[secSymConvert]/balanceAmt > _rebalance):                            
        amtRe =(balance[secSymConvert]-balanceAmt)/2 #re amtBase
        amtRe = amtRe/rateAsk                                     #re amtSec
        res ={'error':0, 'amtBase':(balance[secSymConvert]-balanceAmt)/2, 'amtRe':amtRe}
        print(res)
        if(amtBase > 20):
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            if('error' not in res):
                res=res['result']
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'buy{baseSymbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                print(res)

        
    elif(change < -_rebalance):                        # sec < THB ,_Rebalance%
        amtBase = (abs(change)*balance[baseSymbol])//2       #จำนวณเงิน base ที่ต้อง Reblance หน่วย base 
        res ={'1':amtSec, '2':rateAsk}
        print(res)
        if(amtBase > 20):
            #res = bitkubAPI.placeOrder(_symbol, 'sell', amtRe, rateBid, 'market')
            if('error' not in res):
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'sell{secSymbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                 print(res['result'])
82/68:
initialization()
main()
82/69: 99.430619235075+99.430619235075
82/70: 486 -99.430619235075
82/71:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    baseSymbol  = _symbolSplit[0]
    secSymbol   = _symbolSplit[1]
    secSymConvert = _symbolSplit[1]+"convert"

    balance = { baseSymbol      :   bitkubAPI.balance()[baseSymbol]['available'],
                secSymbol       :   bitkubAPI.balance()[secSymbol]['available'],
                secSymConvert   :   bitkubAPI.balance()[secSymbol]['available']*rateAsk
            }
    
    
    
    #reblanceCondition
    totalAmt =balance[secSymConvert] + balance[baseSymbol]
    balanceAmt = totalAmt/2
    print(f'balance[baseSymbol] {balance[baseSymbol]}'')
    print(f'balance[secSymConvert] {balance[secSymConvert]}'')
    print(f'totalAmt {totalAmt}'')
    print(f'balanceAmt {balanceAmt}'')
    print(f'{baseSymbol}:{round(balance[baseSymbol], 2)} {secSymConvert}:{round(balance[secSymConvert], 2)} totalAmt:{totalAmt}   {datetime.datetime.fromtimestamp(tsAsk)}')
    
    if(balance[secSymConvert]/balanceAmt > _rebalance):  
        amtRe =(balance[secSymConvert]-balanceAmt)/2 #re amtBase
        amtRe = amtRe/rateAsk                                     #re amtSec
        res ={'error':0, 'amtBase':(balance[secSymConvert]-balanceAmt)/2, 'amtRe':amtRe}
        print(res)
        if(amtBase > 20):
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            if('error' not in res):
                res=res['result']
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'buy{baseSymbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                print(res)

        
    elif(change < -_rebalance):                        # sec < THB ,_Rebalance%
        amtBase = (abs(change)*balance[baseSymbol])//2       #จำนวณเงิน base ที่ต้อง Reblance หน่วย base 
        res ={'1':amtSec, '2':rateAsk}
        print(res)
        if(amtBase > 20):
            #res = bitkubAPI.placeOrder(_symbol, 'sell', amtRe, rateBid, 'market')
            if('error' not in res):
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'sell{secSymbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                 print(res['result'])
82/72:
initialization()
main()
82/73:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    baseSymbol  = _symbolSplit[0]
    secSymbol   = _symbolSplit[1]
    secSymConvert = _symbolSplit[1]+"convert"

    port = { baseSymbol      :   bitkubAPI.balance()[baseSymbol]['available'],
                secSymbol       :   bitkubAPI.balance()[secSymbol]['available'],
                secSymConvert   :   bitkubAPI.balance()[secSymbol]['available']*rateAsk
            }
    
    
    
    #reblanceCondition
    totalAmt =port[secSymConvert] + port['baseSymbol']
    balanceAmt = totalAmt/2
    print(f'port[baseSymbol] {port['baseSymbol']}'')
    print(f'port[secSymConvert] {port['secSymConvert']}'')
    print(f'totalAmt {totalAmt}'')
    print(f'balanceAmt {balanceAmt}'')
    print(f'{baseSymbol}:{round(port['baseSymbol'], 2)} {secSymConvert}:{round(port['secSymConvert'], 2)} totalAmt:{totalAmt}   {datetime.datetime.fromtimestamp(tsAsk)}')
    
    if(balance[secSymConvert]/balanceAmt > _rebalance):  
        amtRe =(port['secSymConvert']-balanceAmt)/2 #re amtBase
        amtRe = amtRe/rateAsk                                     #re amtSec
        res ={'error':0, 'amtBase':(port['secSymConvert']-port)/2, 'amtRe':amtRe}
        print(res)
        if(amtBase > 20):
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            if('error' not in res):
                res=res['result']
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'buy{baseSymbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                print(res)

        
    elif(change < -_rebalance):                        # sec < THB ,_Rebalance%
        amtBase = (abs(change)*balance[baseSymbol])//2       #จำนวณเงิน base ที่ต้อง Reblance หน่วย base 
        res ={'1':amtSec, '2':rateAsk}
        print(res)
        if(amtBase > 20):
            #res = bitkubAPI.placeOrder(_symbol, 'sell', amtRe, rateBid, 'market')
            if('error' not in res):
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'sell{secSymbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                 print(res['result'])
82/74:
initialization()
main()
82/75:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    baseSymbol  = _symbolSplit[0]
    secSymbol   = _symbolSplit[1]
    secSymConvert = _symbolSplit[1]+"convert"

    port = { baseSymbol      :   bitkubAPI.balance()[baseSymbol]['available'],
                secSymbol       :   bitkubAPI.balance()[secSymbol]['available'],
                secSymConvert   :   bitkubAPI.balance()[secSymbol]['available']*rateAsk
            }
    
    
    
    #reblanceCondition
    totalAmt =port[secSymConvert] + port['baseSymbol']
    balanceAmt = totalAmt/2
    print(f'port[baseSymbol] {port['baseSymbol']}')
    print(f'port[secSymConvert] {port['secSymConvert']}')
    print(f'totalAmt {totalAmt}')
    print(f'balanceAmt {balanceAmt}')
    print(f'{baseSymbol}:{round(port['baseSymbol'], 2)} {secSymConvert}:{round(port['secSymConvert'], 2)} totalAmt:{totalAmt}   {datetime.datetime.fromtimestamp(tsAsk)}')
    
    if(balance[secSymConvert]/balanceAmt > _rebalance):  
        amtRe =(port['secSymConvert']-balanceAmt)/2 #re amtBase
        amtRe = amtRe/rateAsk                                     #re amtSec
        res ={'error':0, 'amtBase':(port['secSymConvert']-port)/2, 'amtRe':amtRe}
        print(res)
        if(amtRe > 20):
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            if('error' not in res):
                res=res['result']
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'buy{baseSymbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                print(res)

        
    elif(change < -_rebalance):                        # sec < THB ,_Rebalance%
        amtBase = (abs(change)*balance[baseSymbol])//2       #จำนวณเงิน base ที่ต้อง Reblance หน่วย base 
        res ={'1':amtSec, '2':rateAsk}
        print(res)
        if(amtBase > 20):
            #res = bitkubAPI.placeOrder(_symbol, 'sell', amtRe, rateBid, 'market')
            if('error' not in res):
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'sell{secSymbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                 print(res['result'])
82/76:
initialization()
main()
82/77:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    baseSymbol  = _symbolSplit[0]
    secSymbol   = _symbolSplit[1]
    secSymConvert = _symbolSplit[1]+"convert"

    port = { baseSymbol      :   bitkubAPI.balance()[baseSymbol]['available'],
                secSymbol       :   bitkubAPI.balance()[secSymbol]['available'],
                secSymConvert   :   bitkubAPI.balance()[secSymbol]['available']*rateAsk
            }
    
    
    
    #reblanceCondition
    totalAmt =port[secSymConvert] + port['baseSymbol']
    balanceAmt = totalAmt/2
    print('port[baseSymbol] {}'.format(port['baseSymbol']))
    print(f'port[secSymConvert] {port['secSymConvert']}')
    print(f'totalAmt {totalAmt}')
    print(f'balanceAmt {balanceAmt}')
    print(f'{baseSymbol}:{round(port['baseSymbol'], 2)} {secSymConvert}:{round(port['secSymConvert'], 2)} totalAmt:{totalAmt}   {datetime.datetime.fromtimestamp(tsAsk)}')
    
    if(balance[secSymConvert]/balanceAmt > _rebalance):  
        amtRe =(port['secSymConvert']-balanceAmt)/2 #re amtBase
        amtRe = amtRe/rateAsk                                     #re amtSec
        res ={'error':0, 'amtBase':(port['secSymConvert']-port)/2, 'amtRe':amtRe}
        print(res)
        if(amtRe > 20):
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            if('error' not in res):
                res=res['result']
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'buy{baseSymbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                print(res)

        
    elif(change < -_rebalance):                        # sec < THB ,_Rebalance%
        amtBase = (abs(change)*balance[baseSymbol])//2       #จำนวณเงิน base ที่ต้อง Reblance หน่วย base 
        res ={'1':amtSec, '2':rateAsk}
        print(res)
        if(amtBase > 20):
            #res = bitkubAPI.placeOrder(_symbol, 'sell', amtRe, rateBid, 'market')
            if('error' not in res):
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'sell{secSymbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                 print(res['result'])
82/78:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    baseSymbol  = _symbolSplit[0]
    secSymbol   = _symbolSplit[1]
    secSymConvert = _symbolSplit[1]+"convert"

    port = { baseSymbol      :   bitkubAPI.balance()[baseSymbol]['available'],
                secSymbol       :   bitkubAPI.balance()[secSymbol]['available'],
                secSymConvert   :   bitkubAPI.balance()[secSymbol]['available']*rateAsk
            }
    
    
    
    #reblanceCondition
    totalAmt =port[secSymConvert] + port['baseSymbol']
    balanceAmt = totalAmt/2
    print(f"port[baseSymbol] {port['baseSymbol']}")
    print(f'port[secSymConvert] {port['secSymConvert']}')
    print(f'totalAmt {totalAmt}')
    print(f'balanceAmt {balanceAmt}')
    print(f'{baseSymbol}:{round(port['baseSymbol'], 2)} {secSymConvert}:{round(port['secSymConvert'], 2)} totalAmt:{totalAmt}   {datetime.datetime.fromtimestamp(tsAsk)}')
    
    if(balance[secSymConvert]/balanceAmt > _rebalance):  
        amtRe =(port['secSymConvert']-balanceAmt)/2 #re amtBase
        amtRe = amtRe/rateAsk                                     #re amtSec
        res ={'error':0, 'amtBase':(port['secSymConvert']-port)/2, 'amtRe':amtRe}
        print(res)
        if(amtRe > 20):
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            if('error' not in res):
                res=res['result']
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'buy{baseSymbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                print(res)

        
    elif(change < -_rebalance):                        # sec < THB ,_Rebalance%
        amtBase = (abs(change)*balance[baseSymbol])//2       #จำนวณเงิน base ที่ต้อง Reblance หน่วย base 
        res ={'1':amtSec, '2':rateAsk}
        print(res)
        if(amtBase > 20):
            #res = bitkubAPI.placeOrder(_symbol, 'sell', amtRe, rateBid, 'market')
            if('error' not in res):
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'sell{secSymbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                 print(res['result'])
82/79:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    baseSymbol  = _symbolSplit[0]
    secSymbol   = _symbolSplit[1]
    secSymConvert = _symbolSplit[1]+"convert"

    port = { baseSymbol      :   bitkubAPI.balance()[baseSymbol]['available'],
                secSymbol       :   bitkubAPI.balance()[secSymbol]['available'],
                secSymConvert   :   bitkubAPI.balance()[secSymbol]['available']*rateAsk
            }
    
    
    
    #reblanceCondition
    totalAmt =port['secSymConvert'] + port['baseSymbol']
    balanceAmt = totalAmt/2
    print(f" {port['baseSymbol']}")
    print(f'port[secSymConvert] {port['secSymConvert']}')
    print(f'totalAmt {totalAmt}')
    print(f'balanceAmt {balanceAmt}')
    print(f'{baseSymbol}:{round(port['baseSymbol'], 2)} {secSymConvert}:{round(port['secSymConvert'], 2)} totalAmt:{totalAmt}   {datetime.datetime.fromtimestamp(tsAsk)}')
    
    if(balance[secSymConvert]/balanceAmt > _rebalance):  
        amtRe =(port['secSymConvert']-balanceAmt)/2 #re amtBase
        amtRe = amtRe/rateAsk                                     #re amtSec
        res ={'error':0, 'amtBase':(port['secSymConvert']-port)/2, 'amtRe':amtRe}
        print(res)
        if(amtRe > 20):
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            if('error' not in res):
                res=res['result']
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'buy{baseSymbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                print(res)

        
    elif(change < -_rebalance):                        # sec < THB ,_Rebalance%
        amtBase = (abs(change)*balance[baseSymbol])//2       #จำนวณเงิน base ที่ต้อง Reblance หน่วย base 
        res ={'1':amtSec, '2':rateAsk}
        print(res)
        if(amtBase > 20):
            #res = bitkubAPI.placeOrder(_symbol, 'sell', amtRe, rateBid, 'market')
            if('error' not in res):
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'sell{secSymbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                 print(res['result'])
82/80:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    baseSymbol  = _symbolSplit[0]
    secSymbol   = _symbolSplit[1]
    secSymConvert = _symbolSplit[1]+"convert"

    port = { baseSymbol      :   bitkubAPI.balance()[baseSymbol]['available'],
                secSymbol       :   bitkubAPI.balance()[secSymbol]['available'],
                secSymConvert   :   bitkubAPI.balance()[secSymbol]['available']*rateAsk
            }
    
    
    
    #reblanceCondition
    totalAmt =port['secSymConvert'] + port['baseSymbol']
    balanceAmt = totalAmt/2
    print(f"baseSymbol {port['baseSymbol']}")
    print(f'secSymConvert {port['secSymConvert']}')
    print(f'totalAmt {totalAmt}')
    print(f'balanceAmt {balanceAmt}')
    print(f'{baseSymbol}:{round(port['baseSymbol'], 2)} {secSymConvert}:{round(port['secSymConvert'], 2)} totalAmt:{totalAmt}   {datetime.datetime.fromtimestamp(tsAsk)}')
    
    if(balance[secSymConvert]/balanceAmt > _rebalance):  
        amtRe =(port['secSymConvert']-balanceAmt)/2 #re amtBase
        amtRe = amtRe/rateAsk                                     #re amtSec
        res ={'error':0, 'amtBase':(port['secSymConvert']-port)/2, 'amtRe':amtRe}
        print(res)
        if(amtRe > 20):
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            if('error' not in res):
                res=res['result']
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'buy{baseSymbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                print(res)

        
    elif(change < -_rebalance):                        # sec < THB ,_Rebalance%
        amtBase = (abs(change)*balance[baseSymbol])//2       #จำนวณเงิน base ที่ต้อง Reblance หน่วย base 
        res ={'1':amtSec, '2':rateAsk}
        print(res)
        if(amtBase > 20):
            #res = bitkubAPI.placeOrder(_symbol, 'sell', amtRe, rateBid, 'market')
            if('error' not in res):
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'sell{secSymbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                 print(res['result'])
82/81:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    symbol_1  = _symbolSplit[0]
    symbol_2   = _symbolSplit[1]
    sym2Convert = _symbolSplit[1]+"convert"

    amt_1 = bitkubAPI.balance()[symbol_1]['available'],
    amt_2 = bitkubAPI.balance()[symbol_2]['available'],
    amt2Convert = Amt_2*rateAsk
            
    #reblanceCondition
    totalAmt =amt_1+ amt_2
    balanceAmt = totalAmt/2
    print(f'amt_1 {amt_1}')
    print(f'amt2Convert {amt2Convert}')
    print(f'totalAmt {totalAmt}')
    print(f'balanceAmt {balanceAmt}')
    print(f'{symbol_1}:{round(amt_1, 2)} {symbol_2}:{round(amt_2, 2)} totalAmt:{totalAmt}   {datetime.datetime.fromtimestamp(tsAsk)}')
    
    if(sym2Convert/balanceAmt > _rebalance):  
        amtRe =(amt2Convert-balanceAmt)/2 #re amtBase
        print(res)
        amtRe = amtRe/rateAsk                                     #re amtSec
        print(res)
        if(amtRe > 20):
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            if('error' not in res):
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'buy{_symbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                print(res)

        
    elif(change < -_rebalance):                        # sec < THB ,_Rebalance%
        amtBase = (abs(change)*balance[baseSymbol])//2       #จำนวณเงิน base ที่ต้อง Reblance หน่วย base 
        res ={'1':amtSec, '2':rateAsk}
        print(res)
        if(amtRe > 20):
            #res = bitkubAPI.placeOrder(_symbol, 'sell', amtRe, rateBid, 'market')
            if('error' not in res):
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'sell{_symbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                print(res)
82/82:
initialization()
main()
82/83:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    symbol_1  = _symbolSplit[0]
    symbol_2   = _symbolSplit[1]
    sym2Convert = _symbolSplit[1]+"convert"

    amt_1 = bitkubAPI.balance()[symbol_1]['available'],
    amt_2 = bitkubAPI.balance()[symbol_2]['available'],
    amt2Convert = amt_2*rateAsk
            
    #reblanceCondition
    totalAmt =amt_1+ amt_2
    balanceAmt = totalAmt/2
    print(f'amt_1 {amt_1}')
    print(f'amt2Convert {amt2Convert}')
    print(f'totalAmt {totalAmt}')
    print(f'balanceAmt {balanceAmt}')
    print(f'{symbol_1}:{round(amt_1, 2)} {symbol_2}:{round(amt_2, 2)} totalAmt:{totalAmt}   {datetime.datetime.fromtimestamp(tsAsk)}')
    
    if(sym2Convert/balanceAmt > _rebalance):  
        amtRe =(amt2Convert-balanceAmt)/2 #re amtBase
        print(res)
        amtRe = amtRe/rateAsk                                     #re amtSec
        print(res)
        if(amtRe > 20):
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            if('error' not in res):
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'buy{_symbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                print(res)

        
    elif(change < -_rebalance):                        # sec < THB ,_Rebalance%
        amtBase = (abs(change)*balance[baseSymbol])//2       #จำนวณเงิน base ที่ต้อง Reblance หน่วย base 
        res ={'1':amtSec, '2':rateAsk}
        print(res)
        if(amtRe > 20):
            #res = bitkubAPI.placeOrder(_symbol, 'sell', amtRe, rateBid, 'market')
            if('error' not in res):
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'sell{_symbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                print(res)
82/84:
initialization()
main()
82/85:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    symbol_1  = _symbolSplit[0]
    symbol_2   = _symbolSplit[1]
    sym2Convert = _symbolSplit[1]+"convert"

    amt_1 = bitkubAPI.balance()[symbol_1]['available'],
    amt_2 = bitkubAPI.balance()[symbol_2]['available'],
    print(amt_2)
    
    amt2Convert = amt_2*rateAsk
            
    #reblanceCondition
    totalAmt =amt_1+ amt_2
    balanceAmt = totalAmt/2
    print(f'amt_1 {amt_1}')
    print(f'amt2Convert {amt2Convert}')
    print(f'totalAmt {totalAmt}')
    print(f'balanceAmt {balanceAmt}')
    print(f'{symbol_1}:{round(amt_1, 2)} {symbol_2}:{round(amt_2, 2)} totalAmt:{totalAmt}   {datetime.datetime.fromtimestamp(tsAsk)}')
    
    if(sym2Convert/balanceAmt > _rebalance):  
        amtRe =(amt2Convert-balanceAmt)/2 #re amtBase
        print(res)
        amtRe = amtRe/rateAsk                                     #re amtSec
        print(res)
        if(amtRe > 20):
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            if('error' not in res):
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'buy{_symbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                print(res)

        
    elif(change < -_rebalance):                        # sec < THB ,_Rebalance%
        amtBase = (abs(change)*balance[baseSymbol])//2       #จำนวณเงิน base ที่ต้อง Reblance หน่วย base 
        res ={'1':amtSec, '2':rateAsk}
        print(res)
        if(amtRe > 20):
            #res = bitkubAPI.placeOrder(_symbol, 'sell', amtRe, rateBid, 'market')
            if('error' not in res):
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'sell{_symbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                print(res)
82/86:
initialization()
main()
82/87:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    symbol_1  = _symbolSplit[0]
    symbol_2   = _symbolSplit[1]
    sym2Convert = _symbolSplit[1]+"convert"

    amt_1 = bitkubAPI.balance()[symbol_1]['available'],
    amt_2 = bitkubAPI.balance()[symbol_2]['available'],
    
    print(bitkubAPI.balance()[symbol_2])
    print(amt_2)
    
    amt2Convert = amt_2*rateAsk
            
    #reblanceCondition
    totalAmt =amt_1+ amt_2
    balanceAmt = totalAmt/2
    print(f'amt_1 {amt_1}')
    print(f'amt2Convert {amt2Convert}')
    print(f'totalAmt {totalAmt}')
    print(f'balanceAmt {balanceAmt}')
    print(f'{symbol_1}:{round(amt_1, 2)} {symbol_2}:{round(amt_2, 2)} totalAmt:{totalAmt}   {datetime.datetime.fromtimestamp(tsAsk)}')
    
    if(sym2Convert/balanceAmt > _rebalance):  
        amtRe =(amt2Convert-balanceAmt)/2 #re amtBase
        print(res)
        amtRe = amtRe/rateAsk                                     #re amtSec
        print(res)
        if(amtRe > 20):
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            if('error' not in res):
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'buy{_symbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                print(res)

        
    elif(change < -_rebalance):                        # sec < THB ,_Rebalance%
        amtBase = (abs(change)*balance[baseSymbol])//2       #จำนวณเงิน base ที่ต้อง Reblance หน่วย base 
        res ={'1':amtSec, '2':rateAsk}
        print(res)
        if(amtRe > 20):
            #res = bitkubAPI.placeOrder(_symbol, 'sell', amtRe, rateBid, 'market')
            if('error' not in res):
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'sell{_symbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                print(res)
82/88:
initialization()
main()
82/89:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    symbol_1  = _symbolSplit[0]
    symbol_2   = _symbolSplit[1]
    sym2Convert = _symbolSplit[1]+"convert"

    amt_1 = bitkubAPI.balance()[symbol_1]['available']
    amt_2 = bitkubAPI.balance()[symbol_2]['available']
    amt2Convert = amt_2*rateAsk
            
    #reblanceCondition
    totalAmt =amt_1+ amt_2
    balanceAmt = totalAmt/2
    print(f'amt_1 {amt_1}')
    print(f'amt2Convert {amt2Convert}')
    print(f'totalAmt {totalAmt}')
    print(f'balanceAmt {balanceAmt}')
    print(f'{symbol_1}:{round(amt_1, 2)} {symbol_2}:{round(amt_2, 2)} totalAmt:{totalAmt}   {datetime.datetime.fromtimestamp(tsAsk)}')
    
    if(sym2Convert/balanceAmt > _rebalance):  
        amtRe =(amt2Convert-balanceAmt)/2 #re amtBase
        print(res)
        amtRe = amtRe/rateAsk                                     #re amtSec
        print(res)
        if(amtRe > 20):
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            if('error' not in res):
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'buy{_symbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                print(res)

        
    elif(change < -_rebalance):                        # sec < THB ,_Rebalance%
        amtBase = (abs(change)*balance[baseSymbol])//2       #จำนวณเงิน base ที่ต้อง Reblance หน่วย base 
        res ={'1':amtSec, '2':rateAsk}
        print(res)
        if(amtRe > 20):
            #res = bitkubAPI.placeOrder(_symbol, 'sell', amtRe, rateBid, 'market')
            if('error' not in res):
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'sell{_symbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                print(res)
82/90:
initialization()
main()
82/91:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    symbol_1  = _symbolSplit[0]
    symbol_2   = _symbolSplit[1]
    sym2Convert = _symbolSplit[1]+"convert"

    amt_1 = bitkubAPI.balance()[symbol_1]['available']
    amt_2 = bitkubAPI.balance()[symbol_2]['available']
    amt2Convert = amt_2*rateAsk
            
    #reblanceCondition
    totalAmt =amt_1+ amt2Convert
    balanceAmt = totalAmt/2
    print(f'amt_1 {amt_1}')
    print(f'amt2Convert {amt2Convert}')
    print(f'totalAmt {totalAmt}')
    print(f'balanceAmt {balanceAmt}')
    print(f'{symbol_1}:{round(amt_1, 2)} {symbol_2}:{round(amt_2, 2)} totalAmt:{totalAmt}   {datetime.datetime.fromtimestamp(tsAsk)}')
    
    if(sym2Convert/balanceAmt > _rebalance):  
        amtRe =(amt2Convert-balanceAmt)/2 #re amtBase
        print(res)
        amtRe = amtRe/rateAsk                                     #re amtSec
        print(res)
        if(amtRe > 20):
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            if('error' not in res):
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'buy{_symbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                print(res)

        
    elif(change < -_rebalance):                        # sec < THB ,_Rebalance%
        amtBase = (abs(change)*balance[baseSymbol])//2       #จำนวณเงิน base ที่ต้อง Reblance หน่วย base 
        res ={'1':amtSec, '2':rateAsk}
        print(res)
        if(amtRe > 20):
            #res = bitkubAPI.placeOrder(_symbol, 'sell', amtRe, rateBid, 'market')
            if('error' not in res):
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'sell{_symbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                print(res)
82/92:
initialization()
main()
82/93: 568.6304395868999/2
82/94:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    symbol_1  = _symbolSplit[0]
    symbol_2   = _symbolSplit[1]
    sym2Convert = _symbolSplit[1]+"convert"

    amt_1 = bitkubAPI.balance()[symbol_1]['available']
    amt_2 = bitkubAPI.balance()[symbol_2]['available']
    amt2Convert = amt_2*rateAsk
            
    #reblanceCondition
    totalAmt =amt_1+ amt2Convert
    balanceAmt = totalAmt/2
    print(f'{symbol_1}:{round(amt_1, 2)} {symbol_2}:{round(amt_2, 2)} totalAmt:{round(totalAmt, 2)}   {datetime.datetime.fromtimestamp(tsAsk)}')
    
    type(sym2Convert)
    type(balanceAmt)
    type(_rebalance)
    if(sym2Convert/balanceAmt > _rebalance):  
        amtRe =(amt2Convert-balanceAmt)/2 #re amtBase
        print(res)
        amtRe = amtRe/rateAsk                                     #re amtSec
        print(res)
        if(amtRe > 20):
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            if('error' not in res):
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'buy{_symbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                print(res)

        
    elif(change < -_rebalance):                        # sec < THB ,_Rebalance%
        amtBase = (abs(change)*balance[baseSymbol])//2       #จำนวณเงิน base ที่ต้อง Reblance หน่วย base 
        res ={'1':amtSec, '2':rateAsk}
        print(res)
        if(amtRe > 20):
            #res = bitkubAPI.placeOrder(_symbol, 'sell', amtRe, rateBid, 'market')
            if('error' not in res):
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'sell{_symbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                print(res)
82/95:
initialization()
main()
82/96:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    symbol_1  = _symbolSplit[0]
    symbol_2   = _symbolSplit[1]
    sym2Convert = _symbolSplit[1]+"convert"

    amt_1 = bitkubAPI.balance()[symbol_1]['available']
    amt_2 = bitkubAPI.balance()[symbol_2]['available']
    amt2Convert = amt_2*rateAsk
            
    #reblanceCondition
    totalAmt =amt_1+ amt2Convert
    balanceAmt = totalAmt/2
    print(f'{symbol_1}:{round(amt_1, 2)} {symbol_2}:{round(amt_2, 2)} totalAmt:{round(totalAmt, 2)}   {datetime.datetime.fromtimestamp(tsAsk)}')
    
    print(type(sym2Convert))
    print(type(balanceAmt))
    print(type(_rebalance))
    if(sym2Convert/balanceAmt > _rebalance):  
        amtRe =(amt2Convert-balanceAmt)/2 #re amtBase
        print(res)
        amtRe = amtRe/rateAsk                                     #re amtSec
        print(res)
        if(amtRe > 20):
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            if('error' not in res):
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'buy{_symbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                print(res)

        
    elif(change < -_rebalance):                        # sec < THB ,_Rebalance%
        amtBase = (abs(change)*balance[baseSymbol])//2       #จำนวณเงิน base ที่ต้อง Reblance หน่วย base 
        res ={'1':amtSec, '2':rateAsk}
        print(res)
        if(amtRe > 20):
            #res = bitkubAPI.placeOrder(_symbol, 'sell', amtRe, rateBid, 'market')
            if('error' not in res):
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'sell{_symbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                print(res)
82/97:
initialization()
main()
82/98:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    symbol_1  = _symbolSplit[0]
    symbol_2   = _symbolSplit[1]
    sym2Convert = _symbolSplit[1]+"convert"

    amt_1 = bitkubAPI.balance()[symbol_1]['available']
    amt_2 = bitkubAPI.balance()[symbol_2]['available']
    amt2Convert = amt_2*rateAsk
            
    #reblanceCondition
    totalAmt =amt_1+ amt2Convert
    balanceAmt = totalAmt/2
    print(f'{symbol_1}:{round(amt_1, 2)} {symbol_2}:{round(amt_2, 2)} totalAmt:{round(totalAmt, 2)}   {datetime.datetime.fromtimestamp(tsAsk)}')
    

    if(amt2Convert/balanceAmt > _rebalance):  
        amtRe =(amt2Convert-balanceAmt)/2 #re amtBase
        print(amtRe)
        amtRe = amtRe/rateAsk                                     #re amtSec
        print(amtRe)
        if(amtRe > 20):
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            if('error' not in res):
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'buy{_symbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                print(res)

        
    elif(change < -_rebalance):                        # sec < THB ,_Rebalance%
        amtBase = (abs(change)*balance[baseSymbol])//2       #จำนวณเงิน base ที่ต้อง Reblance หน่วย base 
        res ={'1':amtSec, '2':rateAsk}
        print(res)
        if(amtRe > 20):
            #res = bitkubAPI.placeOrder(_symbol, 'sell', amtRe, rateBid, 'market')
            if('error' not in res):
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'sell{_symbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                print(res)
82/99:
initialization()
main()
82/100:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    symbol_1  = _symbolSplit[0]
    symbol_2   = _symbolSplit[1]
    sym2Convert = _symbolSplit[1]+"convert"

    amt_1 = bitkubAPI.balance()[symbol_1]['available']
    amt_2 = bitkubAPI.balance()[symbol_2]['available']
    amt2Convert = amt_2*rateAsk
            
    #reblanceCondition
    totalAmt =amt_1+ amt2Convert
    balanceAmt = totalAmt/2
    print(f'{symbol_1}:{round(amt_1, 2)} {symbol_2}:{round(amt_2, 2)} totalAmt:{round(totalAmt, 2)}   {datetime.datetime.fromtimestamp(tsAsk)}')
    

    if(amt2Convert/balanceAmt > _rebalance):  
        amtRe =(amt2Convert-balanceAmt)/2 #re amtBase
        print(f'balanceAmt {balanceAmt}')
        print(f'amt2Convert {amt2Convert}')
        print(f'amtRe {amtRe}')
        amtRe = amtRe/rateAsk                                     #re amtSec
        print(amtRe)
        if(amtRe > 20):
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            if('error' not in res):
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'buy{_symbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                print(res)

        
    elif(change < -_rebalance):                        # sec < THB ,_Rebalance%
        amtBase = (abs(change)*balance[baseSymbol])//2       #จำนวณเงิน base ที่ต้อง Reblance หน่วย base 
        res ={'1':amtSec, '2':rateAsk}
        print(res)
        if(amtRe > 20):
            #res = bitkubAPI.placeOrder(_symbol, 'sell', amtRe, rateBid, 'market')
            if('error' not in res):
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'sell{_symbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                print(res)
82/101:
initialization()
main()
82/102: 481.0678328223-285.21891641114996
82/103: 195.84891641115001/2
82/104: 481.0678328223 - 97.92445820557501
82/105:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    symbol_1  = _symbolSplit[0]
    symbol_2   = _symbolSplit[1]
    sym2Convert = _symbolSplit[1]+"convert"

    amt_1 = bitkubAPI.balance()[symbol_1]['available']
    amt_2 = bitkubAPI.balance()[symbol_2]['available']
    amt2Convert = amt_2*rateAsk
            
    #reblanceCondition
    totalAmt =amt_1+ amt2Convert
    balanceAmt = totalAmt/2
    print(f'{symbol_1}:{round(amt_1, 2)} {symbol_2}:{round(amt_2, 2)} totalAmt:{round(totalAmt, 2)}   {datetime.datetime.fromtimestamp(tsAsk)}')
    

    if(amt2Convert/balanceAmt > _rebalance):  
        amtRe =(amt2Convert-amt_1)/2 #re amtBase
        print(f'balanceAmt {balanceAmt}')
        print(f'amt2Convert {amt2Convert}')
        print(f'amtRe {amtRe}')
        amtRe = amtRe/rateAsk                                     #re amtSec
        print(amtRe)
        if(amtRe > 20):
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            if('error' not in res):
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'buy{_symbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                print(res)

        
    elif(change < -_rebalance):                        # sec < THB ,_Rebalance%
        amtBase = (abs(change)*balance[baseSymbol])//2       #จำนวณเงิน base ที่ต้อง Reblance หน่วย base 
        res ={'1':amtSec, '2':rateAsk}
        print(res)
        if(amtRe > 20):
            #res = bitkubAPI.placeOrder(_symbol, 'sell', amtRe, rateBid, 'market')
            if('error' not in res):
                amtOrder = res['amt']
                ratOrder = res['rat']
                recOrder = res['rec']
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'sell{_symbol} {amtOrder} at{ratOrder} {recOrder}   {tsOrder}')
            else:
                print(res)
82/106:
initialization()
main()
82/107: 481.0678328223 - 195.54768420524996
82/108: 89.37  + 195.54768420524996
82/109:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    symbol_1  = _symbolSplit[0]
    symbol_2   = _symbolSplit[1]
    sym2Convert = _symbolSplit[1]+"convert"

    amt_1 = bitkubAPI.balance()[symbol_1]['available']
    amt_2 = bitkubAPI.balance()[symbol_2]['available']
    amt2Convert = amt_2*rateAsk
            
    #reblanceCondition
    totalAmt =amt_1+ amt2Convert
    balanceAmt = totalAmt/2
    print(f'{symbol_1}:{round(amt_1, 2)} {symbol_2}:{round(amt_2, 2)} totalAmt:{round(totalAmt, 2)}   {datetime.datetime.fromtimestamp(tsAsk)}')
    

    if(amt2Convert/balanceAmt > _rebalance):  
        amtRe =(amt2Convert-amt_1)/2 #re amt_1
        amtRe = amtRe/rateAsk             #re amt_2
        if(amtRe > 20):
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            res = {'amt':1,'rat':1,'rec':1,'amt':1,}
            if('error' not in res):
                tsOrder = 0#datetime.datetime.fromtimestamp(res['ts'])
                print(f'buy{_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}')
            else:
                print(res)

        
    if(amt_1/balanceAmt > _rebalance):  
        amtRe =(amt_1-amt2Convert)/2 #re amt_1
        if(amtRe > 20):
            res = bitkubAPI.placeOrder(_symbol,'sell', amtRe, rateAsk, 'market')
            if('error' not in res):
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'buy{_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}')
            else:
                print(res)
82/110:
import datetime
from datetime import datetime as dt
import numpy as np
from BitkubTrade import Bitkub
import time 
# API info
API_HOST = 'https://api.bitkub.com'
API_KEY = '343f340ba1aafd4a4d056801c791f14d'
API_SECRET = b'4fd33427a5d4dfddb93ce38251c4d8e5'
82/111:
def initialization():  
    print("----------- Initialize -----------")
    #--------------------------variable-----------------------------
    #ProductSetting
    global _symbol, _symbolSplit ,_rebalance
    _symbol = 'THB_XRP'  # THB_XRP
    _symbolSplit =  _symbol.split("_")
    _rebalance = 0.10#0.1 = 10% min 20 THB
    #SystemSetting
    global _system
    _system = True

    #API
    global bitkubAPI
    bitkubAPI=Bitkub(API_HOST,API_KEY,API_SECRET)
82/112:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    symbol_1  = _symbolSplit[0]
    symbol_2   = _symbolSplit[1]
    sym2Convert = _symbolSplit[1]+"convert"

    amt_1 = bitkubAPI.balance()[symbol_1]['available']
    amt_2 = bitkubAPI.balance()[symbol_2]['available']
    amt2Convert = amt_2*rateAsk
            
    #reblanceCondition
    totalAmt =amt_1+ amt2Convert
    balanceAmt = totalAmt/2
    print(f'{symbol_1}:{round(amt_1, 2)} {symbol_2}:{round(amt_2, 2)} totalAmt:{round(totalAmt, 2)}   {datetime.datetime.fromtimestamp(tsAsk)}')
    

    if(amt2Convert/balanceAmt > _rebalance):  
        amtRe =(amt2Convert-amt_1)/2 #re amt_1
        amtRe = amtRe/rateAsk             #re amt_2
        if(amtRe > 20):
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            res = {'amt':1,'rat':1,'rec':1,'amt':1,}
            if('error' not in res):
                tsOrder = 0#datetime.datetime.fromtimestamp(res['ts'])
                print(f'buy{_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}')
            else:
                print(res)

        
    if(amt_1/balanceAmt > _rebalance):  
        amtRe =(amt_1-amt2Convert)/2 #re amt_1
        if(amtRe > 20):
            res = bitkubAPI.placeOrder(_symbol,'sell', amtRe, rateAsk, 'market')
            if('error' not in res):
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'buy{_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}')
            else:
                print(res)
82/113:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    symbol_1  = _symbolSplit[0]
    symbol_2   = _symbolSplit[1]
    sym2Convert = _symbolSplit[1]+"convert"

    amt_1 = bitkubAPI.balance()[symbol_1]['available']
    amt_2 = bitkubAPI.balance()[symbol_2]['available']
    amt2Convert = amt_2*rateAsk
            
    #reblanceCondition
    totalAmt =amt_1+ amt2Convert
    balanceAmt = totalAmt/2
    print(f'{symbol_1}:{round(amt_1, 2)} {symbol_2}:{round(amt_2, 2)} totalAmt:{round(totalAmt, 2)}   {datetime.datetime.fromtimestamp(tsAsk)}')
    print(_symbol)

    if(amt2Convert/balanceAmt > _rebalance):  
        amtRe =(amt2Convert-amt_1)/2 #re amt_1
        amtRe = amtRe/rateAsk             #re amt_2
        if(amtRe > 20):
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            res = {'amt':1,'rat':1,'rec':1,'amt':1,}
            if('error' not in res):
                tsOrder = 0#datetime.datetime.fromtimestamp(res['ts'])
                print(f'buy{_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}')
            else:
                print(res)

        
    if(amt_1/balanceAmt > _rebalance):  
        amtRe =(amt_1-amt2Convert)/2 #re amt_1
        if(amtRe > 20):
            res = bitkubAPI.placeOrder(_symbol,'sell', amtRe, rateAsk, 'market')
            if('error' not in res):
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'buy{_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}')
            else:
                print(res)
82/114:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    symbol_1  = _symbolSplit[0]
    symbol_2   = _symbolSplit[1]
    sym2Convert = _symbolSplit[1]+"convert"

    amt_1 = bitkubAPI.balance()[symbol_1]['available']
    amt_2 = bitkubAPI.balance()[symbol_2]['available']
    amt2Convert = amt_2*rateAsk
            
    #reblanceCondition
    totalAmt =amt_1+ amt2Convert
    balanceAmt = totalAmt/2
    print(f'{symbol_1}:{round(amt_1, 2)} {symbol_2}:{round(amt_2, 2)} totalAmt:{round(totalAmt, 2)}   {datetime.datetime.fromtimestamp(tsAsk)}')
 

    if(amt2Convert/balanceAmt > _rebalance):  
        amtRe =(amt2Convert-amt_1)/2 #re amt_1
        amtRe = amtRe/rateAsk             #re amt_2
        if(amtRe > 20):
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            res = {'amt':1,'rat':1,'rec':1,'amt':1,}
            if('error' not in res):
                tsOrder = 0#datetime.datetime.fromtimestamp(res['ts'])
                print(f'buy_symbol{res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}')
            else:
                print(res)

        
    if(amt_1/balanceAmt > _rebalance):  
        amtRe =(amt_1-amt2Convert)/2 #re amt_1
        if(amtRe > 20):
            res = bitkubAPI.placeOrder(_symbol,'sell', amtRe, rateAsk, 'market')
            if('error' not in res):
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'buy{_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}')
            else:
                print(res)
82/115:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    symbol_1  = _symbolSplit[0]
    symbol_2   = _symbolSplit[1]
    sym2Convert = _symbolSplit[1]+"convert"

    amt_1 = bitkubAPI.balance()[symbol_1]['available']
    amt_2 = bitkubAPI.balance()[symbol_2]['available']
    amt2Convert = amt_2*rateAsk
            
    #reblanceCondition
    totalAmt =amt_1+ amt2Convert
    balanceAmt = totalAmt/2
    print(f'{symbol_1}:{round(amt_1, 2)} {symbol_2}:{round(amt_2, 2)} totalAmt:{round(totalAmt, 2)}   {datetime.datetime.fromtimestamp(tsAsk)}')
 

    if(amt2Convert/balanceAmt > _rebalance):  
        amtRe =(amt2Convert-amt_1)/2 #re amt_1
        amtRe = amtRe/rateAsk             #re amt_2
        if(amtRe > 20):
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            res = {'amt':1,'rat':1,'rec':1,'amt':1,}
            if('error' not in res):
                tsOrder = 0#datetime.datetime.fromtimestamp(res['ts'])
                print(f"buy_symbol{res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}"")
            else:
                print(res)

        
    if(amt_1/balanceAmt > _rebalance):  
        amtRe =(amt_1-amt2Convert)/2 #re amt_1
        if(amtRe > 20):
            res = bitkubAPI.placeOrder(_symbol,'sell', amtRe, rateAsk, 'market')
            if('error' not in res):
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'buy{_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}')
            else:
                print(res)
82/116:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    symbol_1  = _symbolSplit[0]
    symbol_2   = _symbolSplit[1]
    sym2Convert = _symbolSplit[1]+"convert"

    amt_1 = bitkubAPI.balance()[symbol_1]['available']
    amt_2 = bitkubAPI.balance()[symbol_2]['available']
    amt2Convert = amt_2*rateAsk
            
    #reblanceCondition
    totalAmt =amt_1+ amt2Convert
    balanceAmt = totalAmt/2
    print(f'{symbol_1}:{round(amt_1, 2)} {symbol_2}:{round(amt_2, 2)} totalAmt:{round(totalAmt, 2)}   {datetime.datetime.fromtimestamp(tsAsk)}')
 

    if(amt2Convert/balanceAmt > _rebalance):  
        amtRe =(amt2Convert-amt_1)/2 #re amt_1
        amtRe = amtRe/rateAsk             #re amt_2
        if(amtRe > 20):
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            res = {'amt':1,'rat':1,'rec':1,'amt':1,}
            if('error' not in res):
                tsOrder = 0#datetime.datetime.fromtimestamp(res['ts'])
                print(f"buy_symbol{res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}")
            else:
                print(res)

        
    if(amt_1/balanceAmt > _rebalance):  
        amtRe =(amt_1-amt2Convert)/2 #re amt_1
        if(amtRe > 20):
            res = bitkubAPI.placeOrder(_symbol,'sell', amtRe, rateAsk, 'market')
            if('error' not in res):
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f'buy{_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}')
            else:
                print(res)
82/117:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    symbol_1  = _symbolSplit[0]
    symbol_2   = _symbolSplit[1]
    sym2Convert = _symbolSplit[1]+"convert"

    amt_1 = bitkubAPI.balance()[symbol_1]['available']
    amt_2 = bitkubAPI.balance()[symbol_2]['available']
    amt2Convert = amt_2*rateAsk
            
    #reblanceCondition
    totalAmt =amt_1+ amt2Convert
    balanceAmt = totalAmt/2
    print(f'{symbol_1}:{round(amt_1, 2)} {symbol_2}:{round(amt_2, 2)} totalAmt:{round(totalAmt, 2)}   {datetime.datetime.fromtimestamp(tsAsk)}')
 

    if(amt2Convert/balanceAmt > _rebalance):  
        amtRe =(amt2Convert-amt_1)/2 #re amt_1
        amtRe = amtRe/rateAsk             #re amt_2
        if(amtRe > 20):
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            res = {'amt':1,'rat':1,'rec':1,'amt':1,}
            if('error' not in res):
                tsOrder = 0#datetime.datetime.fromtimestamp(res['ts'])
                print(f"buy{_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}")
            else:
                print(res)

        
    if(amt_1/balanceAmt > _rebalance):  
        amtRe =(amt_1-amt2Convert)/2 #re amt_1
        if(amtRe > 20):
            res = bitkubAPI.placeOrder(_symbol,'sell', amtRe, rateAsk, 'market')
            if('error' not in res):
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f"buy{_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}")
            else:
                print(res)
82/118:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    symbol_1  = _symbolSplit[0]
    symbol_2   = _symbolSplit[1]
    sym2Convert = _symbolSplit[1]+"convert"

    amt_1 = bitkubAPI.balance()[symbol_1]['available']
    amt_2 = bitkubAPI.balance()[symbol_2]['available']
    amt2Convert = amt_2*rateAsk
            
    #reblanceCondition
    totalAmt =amt_1+ amt2Convert
    balanceAmt = totalAmt/2
    print(f'{symbol_1}:{round(amt_1, 2)} {symbol_2}:{round(amt_2, 2)} totalAmt:{round(totalAmt, 2)}   {datetime.datetime.fromtimestamp(tsAsk)}')
 

    if(amt2Convert/balanceAmt > _rebalance):  
        amtRe =(amt2Convert-amt_1)/2 #re amt_1
        amtRe = amtRe/rateAsk             #re amt_2
        if(amtRe > 20):
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            res = {'amt':1,'rat':1,'rec':1,'amt':1,}
            if('error' not in res):
                tsOrder = 0#datetime.datetime.fromtimestamp(res['ts'])
                print(f"buy{_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}")
            else:
                print(res)

        
    if(amt_1/balanceAmt > _rebalance):  
        amtRe =(amt_1-amt2Convert)/2 #re amt_1
        if(amtRe > 20):
            res = bitkubAPI.placeOrder(_symbol,'sell', amtRe, rateAsk, 'market')
            if('error' not in res):
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f"buy{_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}")
            else:
                print(res)
82/119:
initialization()
main()
82/120:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    symbol_1  = _symbolSplit[0]
    symbol_2   = _symbolSplit[1]
    sym2Convert = _symbolSplit[1]+"convert"

    amt_1 = bitkubAPI.balance()[symbol_1]['available']
    amt_2 = bitkubAPI.balance()[symbol_2]['available']
    amt2Convert = amt_2*rateAsk
            
    #reblanceCondition
    totalAmt =amt_1+ amt2Convert
    balanceAmt = totalAmt/2
    print(f'{symbol_1}:{round(amt_1, 2)} {symbol_2}:{round(amt_2, 2)} totalAmt:{round(totalAmt, 2)}   {datetime.datetime.fromtimestamp(tsAsk)}')
 

    if(amt2Convert/balanceAmt > _rebalance):  
        amtRe =(amt2Convert-amt_1)/2 #re amt_1
        amtRe = amtRe/rateAsk             #re amt_2
        if(amtRe > 20):
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            res = {'amt':1,'rat':1,'rec':1,'amt':1,}
            print('1111')
            if('error' not in res):
                tsOrder = 0#datetime.datetime.fromtimestamp(res['ts'])
                print(f"buy{_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}")
            else:
                print(res)

        
    if(amt_1/balanceAmt > _rebalance):  
        amtRe =(amt_1-amt2Convert)/2 #re amt_1
        if(amtRe > 20):
            res = bitkubAPI.placeOrder(_symbol,'sell', amtRe, rateAsk, 'market')
            if('error' not in res):
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f"buy{_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}")
            else:
                print(res)
82/121:
initialization()
main()
82/122:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    symbol_1  = _symbolSplit[0]
    symbol_2   = _symbolSplit[1]
    sym2Convert = _symbolSplit[1]+"convert"

    amt_1 = bitkubAPI.balance()[symbol_1]['available']
    amt_2 = bitkubAPI.balance()[symbol_2]['available']
    amt2Convert = amt_2*rateAsk
            
    #reblanceCondition
    totalAmt =amt_1+ amt2Convert
    balanceAmt = totalAmt/2
    print(f'{symbol_1}:{round(amt_1, 2)} {symbol_2}:{round(amt_2, 2)} totalAmt:{round(totalAmt, 2)}   {datetime.datetime.fromtimestamp(tsAsk)}')
 
    if(amt2Convert/balanceAmt > _rebalance):  
        amtRe =(amt2Convert-amt_1)/2 #re amt_1
        amtRe = amtRe/rateAsk             #re amt_2
        print('112211')
        if(amtRe > 20):
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            res = {'amt':1,'rat':1,'rec':1,'amt':1,}
            if('error' not in res):
                tsOrder = 0#datetime.datetime.fromtimestamp(res['ts'])
                print(f"buy{_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}")
            else:
                print(res)

        
    if(amt_1/balanceAmt > _rebalance):  
        amtRe =(amt_1-amt2Convert)/2 #re amt_1
        if(amtRe > 20):
            res = bitkubAPI.placeOrder(_symbol,'sell', amtRe, rateAsk, 'market')
            if('error' not in res):
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f"buy{_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}")
            else:
                print(res)
82/123:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    symbol_1  = _symbolSplit[0]
    symbol_2   = _symbolSplit[1]
    sym2Convert = _symbolSplit[1]+"convert"

    amt_1 = bitkubAPI.balance()[symbol_1]['available']
    amt_2 = bitkubAPI.balance()[symbol_2]['available']
    amt2Convert = amt_2*rateAsk
            
    #reblanceCondition
    totalAmt =amt_1+ amt2Convert
    balanceAmt = totalAmt/2
    print(f'{symbol_1}:{round(amt_1, 2)} {symbol_2}:{round(amt_2, 2)} totalAmt:{round(totalAmt, 2)}   {datetime.datetime.fromtimestamp(tsAsk)}')
 
    if(amt2Convert/balanceAmt > _rebalance):  
        amtRe =(amt2Convert-amt_1)/2 #amtRe amt_1
        if(amtRe > 20):
            amtRe = amtRe/rateAsk         #amtRe Convert 
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
                    print('112211')
            res = {'amt':1,'rat':1,'rec':1,'amt':1,}
            if('error' not in res):
                tsOrder = 0#datetime.datetime.fromtimestamp(res['ts'])
                print(f"buy{_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}")
            else:
                print(res)

        
    if(amt_1/balanceAmt > _rebalance):  
        amtRe =(amt_1-amt2Convert)/2 #amtRe amt_1
        if(amtRe > 20):
            res = bitkubAPI.placeOrder(_symbol,'sell', amtRe, rateAsk, 'market')
            if('error' not in res):
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f"buy{_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}")
            else:
                print(res)
82/124:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    symbol_1  = _symbolSplit[0]
    symbol_2   = _symbolSplit[1]
    sym2Convert = _symbolSplit[1]+"convert"

    amt_1 = bitkubAPI.balance()[symbol_1]['available']
    amt_2 = bitkubAPI.balance()[symbol_2]['available']
    amt2Convert = amt_2*rateAsk
            
    #reblanceCondition
    totalAmt =amt_1+ amt2Convert
    balanceAmt = totalAmt/2
    print(f'{symbol_1}:{round(amt_1, 2)} {symbol_2}:{round(amt_2, 2)} totalAmt:{round(totalAmt, 2)}   {datetime.datetime.fromtimestamp(tsAsk)}')
 
    if(amt2Convert/balanceAmt > _rebalance):  
        amtRe =(amt2Convert-amt_1)/2 #amtRe amt_1
        if(amtRe > 20):
            amtRe = amtRe/rateAsk         #amtRe Convert 
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            res = {'amt':1,'rat':1,'rec':1,'amt':1,}
            if('error' not in res):
                tsOrder = 0#datetime.datetime.fromtimestamp(res['ts'])
                print(f"buy{_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}")
            else:
                print(res)

        
    if(amt_1/balanceAmt > _rebalance):  
        amtRe =(amt_1-amt2Convert)/2 #amtRe amt_1
        if(amtRe > 20):
            res = bitkubAPI.placeOrder(_symbol,'sell', amtRe, rateAsk, 'market')
            if('error' not in res):
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f"buy{_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}")
            else:
                print(res)
82/125:
initialization()
main()
83/1:
import datetime
from datetime import datetime as dt
import numpy as np
from BitkubTrade import Bitkub
from mongoDatabase import mongoDatabase
import time 
# API info
API_HOST = 'https://api.bitkub.com'
API_KEY = '343f340ba1aafd4a4d056801c791f14d'
API_SECRET = b'4fd33427a5d4dfddb93ce38251c4d8e5'
84/1:
import datetime
from datetime import datetime as dt
import numpy as np
from BitkubTrade import Bitkub
from mongoDB import mongoDatabase
import time 
# API info
API_HOST = 'https://api.bitkub.com'
API_KEY = '343f340ba1aafd4a4d056801c791f14d'
API_SECRET = b'4fd33427a5d4dfddb93ce38251c4d8e5'
84/2:
# database info
mongo = mongoDatabase(
    database='trading_db'
    ,collection= 'trading_db'
    ,mongodb_srv="mongodb+srv://wasan:1234@cluster0.ujivx.gcp.mongodb.net/trading_db?retryWrites=true&w=majority"
    ,line_token='QHQPbxDrgD35meR5LDh0PniRVDGYUBNrH8ls42ThiKM'
    )
84/3:
# database info
mongo = mongoDatabase(
    database='trading_db'
    ,collection= 'bitkubRebalance'
    ,mongodb_srv="mongodb+srv://wasan:1234@cluster0.ujivx.gcp.mongodb.net/trading_db?retryWrites=true&w=majority"
    ,line_token='QHQPbxDrgD35meR5LDh0PniRVDGYUBNrH8ls42ThiKM'
    )
84/4:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    symbol_1  = _symbolSplit[0]
    symbol_2   = _symbolSplit[1]
    sym2Convert = _symbolSplit[1]+"convert"

    amt_1 = bitkubAPI.balance()[symbol_1]['available']
    amt_2 = bitkubAPI.balance()[symbol_2]['available']
    amt2Convert = amt_2*rateAsk
            
    #reblanceCondition
    totalAmt =amt_1+ amt2Convert
    balanceAmt = totalAmt/2
    print(f'{symbol_1}:{round(amt_1, 2)} {symbol_2}:{round(amt_2, 2)} totalAmt:{round(totalAmt, 2)}   {datetime.datetime.fromtimestamp(tsAsk)}')
 
    if(amt2Convert/balanceAmt > _rebalance):  
        amtRe =(amt2Convert-amt_1)/2 #amtRe amt_1
        if(amtRe > 20):
            amtRe = amtRe/rateAsk         #amtRe Convert 
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            if('error' not in res):
                res={  'position':'buy','symbol':_symbol,'amt':2,'rat':1}
                tsOrder = 0#datetime.datetime.fromtimestamp(res['ts'])
                print(f"buy {_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}")
                lineSendMas(f' buy {_symbol} {res['amt']} {symbol_2} at { res['rat']}  \r\n  totalAmt:{round(totalAmt, 2)') 
                acc.save_db({  'position':'buy',
                                        'symbol':_symbol,
                                        'amt':res['amt'],
                                        'rat':res['rat'],
                                        'total':round(totalAmt, 2),
                                        'time':tsOrder})
            else:
                print(res)

        
    if(amt_1/balanceAmt > _rebalance):  
        amtRe =(amt_1-amt2Convert)/2 #amtRe amt_1
        if(amtRe > 20):
            res = bitkubAPI.placeOrder(_symbol,'sell', amtRe, rateAsk, 'market')
            if('error' not in res):
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f"buy {_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}")
                lineSendMas(f' sell {_symbol} {res['amt']} {symbol_2} at { res['rat']}  \r\n  totalAmt:{round(totalAmt, 2)') 
                acc.save_db({  'position':'sell',
                                        'symbol':_symbol,
                                        'amt':res['amt'],
                                        'rat':res['rat'],
                                        'total':round(totalAmt, 2),
                                        'time':res['rat']})
            else:
                print(res)
84/5:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    symbol_1  = _symbolSplit[0]
    symbol_2   = _symbolSplit[1]
    sym2Convert = _symbolSplit[1]+"convert"

    amt_1 = bitkubAPI.balance()[symbol_1]['available']
    amt_2 = bitkubAPI.balance()[symbol_2]['available']
    amt2Convert = amt_2*rateAsk
            
    #reblanceCondition
    totalAmt =amt_1+ amt2Convert
    balanceAmt = totalAmt/2
    print(f'{symbol_1}:{round(amt_1, 2)} {symbol_2}:{round(amt_2, 2)} totalAmt:{round(totalAmt, 2)}   {datetime.datetime.fromtimestamp(tsAsk)}')
 
    if(amt2Convert/balanceAmt > _rebalance):  
        amtRe =(amt2Convert-amt_1)/2 #amtRe amt_1
        if(amtRe > 20):
            amtRe = amtRe/rateAsk         #amtRe Convert 
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            if('error' not in res):
                res={  'position':'buy','symbol':_symbol,'amt':2,'rat':1}
                tsOrder = 0#datetime.datetime.fromtimestamp(res['ts'])
                print(f"buy {_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}")
                lineSendMas(f" buy {_symbol} {res['amt']} {symbol_2} at { res['rat']}  \r\n  totalAmt:{round(totalAmt, 2)") 
                acc.save_db({  'position':'buy',
                                        'symbol':_symbol,
                                        'amt':res['amt'],
                                        'rat':res['rat'],
                                        'total':round(totalAmt, 2),
                                        'time':tsOrder})
            else:
                print(res)

        
    if(amt_1/balanceAmt > _rebalance):  
        amtRe =(amt_1-amt2Convert)/2 #amtRe amt_1
        if(amtRe > 20):
            res = bitkubAPI.placeOrder(_symbol,'sell', amtRe, rateAsk, 'market')
            if('error' not in res):
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f"buy {_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}")
                lineSendMas(f' sell {_symbol} {res['amt']} {symbol_2} at { res['rat']}  \r\n  totalAmt:{round(totalAmt, 2)') 
                acc.save_db({  'position':'sell',
                                        'symbol':_symbol,
                                        'amt':res['amt'],
                                        'rat':res['rat'],
                                        'total':round(totalAmt, 2),
                                        'time':res['rat']})
            else:
                print(res)
84/6:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    symbol_1  = _symbolSplit[0]
    symbol_2   = _symbolSplit[1]
    sym2Convert = _symbolSplit[1]+"convert"

    amt_1 = bitkubAPI.balance()[symbol_1]['available']
    amt_2 = bitkubAPI.balance()[symbol_2]['available']
    amt2Convert = amt_2*rateAsk
            
    #reblanceCondition
    totalAmt =amt_1+ amt2Convert
    balanceAmt = totalAmt/2
    print(f'{symbol_1}:{round(amt_1, 2)} {symbol_2}:{round(amt_2, 2)} totalAmt:{round(totalAmt, 2)}   {datetime.datetime.fromtimestamp(tsAsk)}')
 
    if(amt2Convert/balanceAmt > _rebalance):  
        amtRe =(amt2Convert-amt_1)/2 #amtRe amt_1
        if(amtRe > 20):
            amtRe = amtRe/rateAsk         #amtRe Convert 
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            if('error' not in res):
                res={  'position':'buy','symbol':_symbol,'amt':2,'rat':1}
                tsOrder = 0#datetime.datetime.fromtimestamp(res['ts'])
                print(f"buy {_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}")
                mongo.lineMsg(f" buy {_symbol} {res['amt']} {symbol_2} at { res['rat']}  \r\n  totalAmt:{round(totalAmt, 2)") 
                mongo.save({  'position':'buy',
                                        'symbol':_symbol,
                                        'amt':res['amt'],
                                        'rat':res['rat'],
                                        'total':round(totalAmt, 2),
                                        'time':tsOrder})
            else:
                print(res)

        
    if(amt_1/balanceAmt > _rebalance):  
        amtRe =(amt_1-amt2Convert)/2 #amtRe amt_1
        if(amtRe > 20):
            res = bitkubAPI.placeOrder(_symbol,'sell', amtRe, rateAsk, 'market')
            if('error' not in res):
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f"buy {_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}")
                mongo.lineMsg(f" buy {_symbol} {res['amt']} {symbol_2} at { res['rat']}  \r\n  totalAmt:{round(totalAmt, 2)") 
                mongo.save({  'position':'sell',
                                        'symbol':_symbol,
                                        'amt':res['amt'],
                                        'rat':res['rat'],
                                        'total':round(totalAmt, 2),
                                        'time':res['rat']})
            else:
                print(res)
84/7:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    symbol_1  = _symbolSplit[0]
    symbol_2   = _symbolSplit[1]
    sym2Convert = _symbolSplit[1]+"convert"

    amt_1 = bitkubAPI.balance()[symbol_1]['available']
    amt_2 = bitkubAPI.balance()[symbol_2]['available']
    amt2Convert = amt_2*rateAsk
            
    #reblanceCondition
    totalAmt =amt_1+ amt2Convert
    balanceAmt = totalAmt/2
    print(f'{symbol_1}:{round(amt_1, 2)} {symbol_2}:{round(amt_2, 2)} totalAmt:{round(totalAmt, 2)}   {datetime.datetime.fromtimestamp(tsAsk)}')
 
    if(amt2Convert/balanceAmt > _rebalance):  
        amtRe =(amt2Convert-amt_1)/2 #amtRe amt_1
        if(amtRe > 20):
            amtRe = amtRe/rateAsk         #amtRe Convert 
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            if('error' not in res):
                res={  'position':'buy','symbol':_symbol,'amt':2,'rat':1}
                tsOrder = 0#datetime.datetime.fromtimestamp(res['ts'])
                print(f"buy {_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}")
                mongo.lineMsg(f" buy {_symbol} {res['amt']} {symbol_2} at { res['rat']}  \r\n  totalAmt:{round(totalAmt, 2)}") 
                mongo.save({  'position':'buy',
                                        'symbol':_symbol,
                                        'amt':res['amt'],
                                        'rat':res['rat'],
                                        'total':round(totalAmt, 2),
                                        'time':tsOrder})
            else:
                print(res)

        
    if(amt_1/balanceAmt > _rebalance):  
        amtRe =(amt_1-amt2Convert)/2 #amtRe amt_1
        if(amtRe > 20):
            res = bitkubAPI.placeOrder(_symbol,'sell', amtRe, rateAsk, 'market')
            if('error' not in res):
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f"buy {_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}")
                mongo.lineMsg(f" buy {_symbol} {res['amt']} {symbol_2} at { res['rat']}  \r\n  totalAmt:{round(totalAmt, 2)}") 
                mongo.save({  'position':'sell',
                                        'symbol':_symbol,
                                        'amt':res['amt'],
                                        'rat':res['rat'],
                                        'total':round(totalAmt, 2),
                                        'time':res['rat']})
            else:
                print(res)
84/8:
initialization()
main()
84/9:
def initialization():  
    print("----------- Initialize -----------")
    #--------------------------variable-----------------------------
    #ProductSetting
    global _symbol, _symbolSplit ,_rebalance
    _symbol = 'THB_XRP'  # THB_XRP
    _symbolSplit =  _symbol.split("_")
    _rebalance = 0.10#0.1 = 10% min 20 THB
    #SystemSetting
    global _system
    _system = True

    #API
    global bitkubAPI
    bitkubAPI=Bitkub(API_HOST,API_KEY,API_SECRET)
84/10:
initialization()
main()
84/11:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    symbol_1  = _symbolSplit[0]
    symbol_2   = _symbolSplit[1]
    sym2Convert = _symbolSplit[1]+"convert"

    amt_1 = bitkubAPI.balance()[symbol_1]['available']
    amt_2 = bitkubAPI.balance()[symbol_2]['available']
    amt2Convert = amt_2*rateAsk
            
    #reblanceCondition
    totalAmt =amt_1+ amt2Convert
    balanceAmt = totalAmt/2
    print(f'{symbol_1}:{round(amt_1, 2)} {symbol_2}:{round(amt_2, 2)} totalAmt:{round(totalAmt, 2)}   {datetime.datetime.fromtimestamp(tsAsk)}')
 
    if(amt2Convert/balanceAmt > _rebalance):  
        amtRe =(amt2Convert-amt_1)/2 #amtRe amt_1
        if(amtRe > 20):
            amtRe = amtRe/rateAsk         #amtRe Convert 
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            res={  'position':'buy','symbol':_symbol,'amt':2,'rat':1}
            if('error' not in res):
                
                tsOrder = 0#datetime.datetime.fromtimestamp(res['ts'])
                print(f"buy {_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}")
                mongo.lineMsg(f" buy {_symbol} {res['amt']} {symbol_2} at { res['rat']}  \r\n  totalAmt:{round(totalAmt, 2)}") 
                mongo.save({  'position':'buy',
                                        'symbol':_symbol,
                                        'amt':res['amt'],
                                        'rat':res['rat'],
                                        'total':round(totalAmt, 2),
                                        'time':tsOrder})
            else:
                print(res)

        
    if(amt_1/balanceAmt > _rebalance):  
        amtRe =(amt_1-amt2Convert)/2 #amtRe amt_1
        if(amtRe > 20):
            res = bitkubAPI.placeOrder(_symbol,'sell', amtRe, rateAsk, 'market')
            if('error' not in res):
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f"buy {_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}")
                mongo.lineMsg(f" buy {_symbol} {res['amt']} {symbol_2} at { res['rat']}  \r\n  totalAmt:{round(totalAmt, 2)}") 
                mongo.save({  'position':'sell',
                                        'symbol':_symbol,
                                        'amt':res['amt'],
                                        'rat':res['rat'],
                                        'total':round(totalAmt, 2),
                                        'time':res['rat']})
            else:
                print(res)
84/12:
initialization()
main()
84/13:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    symbol_1  = _symbolSplit[0]
    symbol_2   = _symbolSplit[1]
    sym2Convert = _symbolSplit[1]+"convert"

    amt_1 = bitkubAPI.balance()[symbol_1]['available']
    amt_2 = bitkubAPI.balance()[symbol_2]['available']
    amt2Convert = amt_2*rateAsk
            
    #reblanceCondition
    totalAmt =amt_1+ amt2Convert
    balanceAmt = totalAmt/2
    print(f'{symbol_1}:{round(amt_1, 2)} {symbol_2}:{round(amt_2, 2)} totalAmt:{round(totalAmt, 2)}   {datetime.datetime.fromtimestamp(tsAsk)}')
 
    if(amt2Convert/balanceAmt > _rebalance):  
        amtRe =(amt2Convert-amt_1)/2 #amtRe amt_1
        if(amtRe > 20):
            amtRe = amtRe/rateAsk         #amtRe Convert 
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            res={  'position':'buy','symbol':_symbol,'amt':2,  'rat':1,'rec':3}
            if('error' not in res):
                
                tsOrder = 0#datetime.datetime.fromtimestamp(res['ts'])
                print(f"buy {_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}")
                mongo.lineMsg(f" buy {_symbol} {res['amt']} {symbol_2} at { res['rat']}  \r\n  totalAmt:{round(totalAmt, 2)}") 
                mongo.save({  'position':'buy',
                                        'symbol':_symbol,
                                        'amt':res['amt'],
                                        'rat':res['rat'],
                                        'total':round(totalAmt, 2),
                                        'time':tsOrder})
            else:
                print(res)

        
    if(amt_1/balanceAmt > _rebalance):  
        amtRe =(amt_1-amt2Convert)/2 #amtRe amt_1
        if(amtRe > 20):
            res = bitkubAPI.placeOrder(_symbol,'sell', amtRe, rateAsk, 'market')
            if('error' not in res):
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f"buy {_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}")
                mongo.lineMsg(f" buy {_symbol} {res['amt']} {symbol_2} at { res['rat']}  \r\n  totalAmt:{round(totalAmt, 2)}") 
                mongo.save({  'position':'sell',
                                        'symbol':_symbol,
                                        'amt':res['amt'],
                                        'rat':res['rat'],
                                        'total':round(totalAmt, 2),
                                        'time':res['rat']})
            else:
                print(res)
84/14:
initialization()
main()
84/15:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    symbol_1  = _symbolSplit[0]
    symbol_2   = _symbolSplit[1]
    sym2Convert = _symbolSplit[1]+"convert"

    amt_1 = bitkubAPI.balance()[symbol_1]['available']
    amt_2 = bitkubAPI.balance()[symbol_2]['available']
    amt2Convert = amt_2*rateAsk
            
    #reblanceCondition
    totalAmt =amt_1+ amt2Convert
    balanceAmt = totalAmt/2
    print(f'{symbol_1}:{round(amt_1, 2)} {symbol_2}:{round(amt_2, 2)} totalAmt:{round(totalAmt, 2)}   {datetime.datetime.fromtimestamp(tsAsk)}')
 
    if(amt2Convert/balanceAmt > _rebalance):  
        amtRe =(amt2Convert-amt_1)/2 #amtRe amt_1
        if(amtRe > 20):
            amtRe = amtRe/rateAsk         #amtRe Convert 
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            res={  'position':'buy','symbol':_symbol,'amt':2,  'rat':1,'rec':3}
            if('error' not in res):
                
                tsOrder = 0#datetime.datetime.fromtimestamp(res['ts'])
                print(f"buy {_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}")
                msg = f" buy {_symbol} {res['amt']} {symbol_2} at { res['rat']}  \r\n  totalAmt:{round(totalAmt, 2)}"
                mongo.lineMsg(msg) 
                mongo.save({  'position':'buy',
                                        'symbol':_symbol,
                                        'amt':res['amt'],
                                        'rat':res['rat'],
                                        'total':round(totalAmt, 2),
                                        'time':tsOrder})
            else:
                print(res)

        
    if(amt_1/balanceAmt > _rebalance):  
        amtRe =(amt_1-amt2Convert)/2 #amtRe amt_1
        if(amtRe > 20):
            res = bitkubAPI.placeOrder(_symbol,'sell', amtRe, rateAsk, 'market')
            if('error' not in res):
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f"buy {_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}")
                mongo.lineMsg(f" buy {_symbol} {res['amt']} {symbol_2} at { res['rat']}  \r\n  totalAmt:{round(totalAmt, 2)}") 
                mongo.save({  'position':'sell',
                                        'symbol':_symbol,
                                        'amt':res['amt'],
                                        'rat':res['rat'],
                                        'total':round(totalAmt, 2),
                                        'time':res['rat']})
            else:
                print(res)
84/16:
initialization()
main()
84/17:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    symbol_1  = _symbolSplit[0]
    symbol_2   = _symbolSplit[1]
    sym2Convert = _symbolSplit[1]+"convert"

    amt_1 = bitkubAPI.balance()[symbol_1]['available']
    amt_2 = bitkubAPI.balance()[symbol_2]['available']
    amt2Convert = amt_2*rateAsk
            
    #reblanceCondition
    totalAmt =amt_1+ amt2Convert
    balanceAmt = totalAmt/2
    print(f'{symbol_1}:{round(amt_1, 2)} {symbol_2}:{round(amt_2, 2)} totalAmt:{round(totalAmt, 2)}   {datetime.datetime.fromtimestamp(tsAsk)}')
 
    if(amt2Convert/balanceAmt > _rebalance):  
        amtRe =(amt2Convert-amt_1)/2 #amtRe amt_1
        if(amtRe > 20):
            amtRe = amtRe/rateAsk         #amtRe Convert 
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            res={  'position':'buy','symbol':_symbol,'amt':2,  'rat':1,'rec':}
            if('error' not in res):
                
                tsOrder = 0#datetime.datetime.fromtimestamp(res['ts'])
                print(f"buy {_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}")
                mongo.lineMsg(f" buy {_symbol} {res['amt']} {symbol_2} at { res['rat']}  \r\n  totalAmt:{round(totalAmt, 2)}") 
                mongo.save({  'position':'buy',
                                        'symbol':_symbol,
                                        'amt':res['amt'],
                                        'rat':res['rat'],
                                        'total':round(totalAmt, 2),
                                        'time':tsOrder})
            else:
                print(res)

        
    if(amt_1/balanceAmt > _rebalance):  
        amtRe =(amt_1-amt2Convert)/2 #amtRe amt_1
        if(amtRe > 20):
            res = bitkubAPI.placeOrder(_symbol,'sell', amtRe, rateAsk, 'market')
            if('error' not in res):
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f"buy {_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}")
                mongo.lineMsg(f" buy {_symbol} {res['amt']} {symbol_2} at { res['rat']}  \r\n  totalAmt:{round(totalAmt, 2)}") 
                mongo.save({  'position':'sell',
                                        'symbol':_symbol,
                                        'amt':res['amt'],
                                        'rat':res['rat'],
                                        'total':round(totalAmt, 2),
                                        'time':res['rat']})
            else:
                print(res)
84/18:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    symbol_1  = _symbolSplit[0]
    symbol_2   = _symbolSplit[1]
    sym2Convert = _symbolSplit[1]+"convert"

    amt_1 = bitkubAPI.balance()[symbol_1]['available']
    amt_2 = bitkubAPI.balance()[symbol_2]['available']
    amt2Convert = amt_2*rateAsk
            
    #reblanceCondition
    totalAmt =amt_1+ amt2Convert
    balanceAmt = totalAmt/2
    print(f'{symbol_1}:{round(amt_1, 2)} {symbol_2}:{round(amt_2, 2)} totalAmt:{round(totalAmt, 2)}   {datetime.datetime.fromtimestamp(tsAsk)}')
 
    if(amt2Convert/balanceAmt > _rebalance):  
        amtRe =(amt2Convert-amt_1)/2 #amtRe amt_1
        if(amtRe > 20):
            amtRe = amtRe/rateAsk         #amtRe Convert 
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            print(_symbol)
            res={  'position':'buy','symbol':_symbol,'amt':2,  'rat':1,'rec':}
            if('error' not in res):
                
                tsOrder = 0#datetime.datetime.fromtimestamp(res['ts'])
                print(f"buy {_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}")
                mongo.lineMsg(f" buy {_symbol} {res['amt']} {symbol_2} at { res['rat']}  \r\n  totalAmt:{round(totalAmt, 2)}") 
                mongo.save({  'position':'buy',
                                        'symbol':_symbol,
                                        'amt':res['amt'],
                                        'rat':res['rat'],
                                        'total':round(totalAmt, 2),
                                        'time':tsOrder})
            else:
                print(res)

        
    if(amt_1/balanceAmt > _rebalance):  
        amtRe =(amt_1-amt2Convert)/2 #amtRe amt_1
        if(amtRe > 20):
            res = bitkubAPI.placeOrder(_symbol,'sell', amtRe, rateAsk, 'market')
            if('error' not in res):
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f"buy {_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}")
                mongo.lineMsg(f" buy {_symbol} {res['amt']} {symbol_2} at { res['rat']}  \r\n  totalAmt:{round(totalAmt, 2)}") 
                mongo.save({  'position':'sell',
                                        'symbol':_symbol,
                                        'amt':res['amt'],
                                        'rat':res['rat'],
                                        'total':round(totalAmt, 2),
                                        'time':res['rat']})
            else:
                print(res)
84/19:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    symbol_1  = _symbolSplit[0]
    symbol_2   = _symbolSplit[1]
    sym2Convert = _symbolSplit[1]+"convert"

    amt_1 = bitkubAPI.balance()[symbol_1]['available']
    amt_2 = bitkubAPI.balance()[symbol_2]['available']
    amt2Convert = amt_2*rateAsk
            
    #reblanceCondition
    totalAmt =amt_1+ amt2Convert
    balanceAmt = totalAmt/2
    print(f'{symbol_1}:{round(amt_1, 2)} {symbol_2}:{round(amt_2, 2)} totalAmt:{round(totalAmt, 2)}   {datetime.datetime.fromtimestamp(tsAsk)}')
 
    if(amt2Convert/balanceAmt > _rebalance):  
        amtRe =(amt2Convert-amt_1)/2 #amtRe amt_1
        if(amtRe > 20):
            amtRe = amtRe/rateAsk         #amtRe Convert 
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            print(_symbol)
            res={  'position':'buy','symbol':'_symbol','amt':2,  'rat':1,'rec':}
            if('error' not in res):
                
                tsOrder = 0#datetime.datetime.fromtimestamp(res['ts'])
                print(f"buy {_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}")
                mongo.lineMsg(f" buy {_symbol} {res['amt']} {symbol_2} at { res['rat']}  \r\n  totalAmt:{round(totalAmt, 2)}") 
                mongo.save({  'position':'buy',
                                        'symbol':_symbol,
                                        'amt':res['amt'],
                                        'rat':res['rat'],
                                        'total':round(totalAmt, 2),
                                        'time':tsOrder})
            else:
                print(res)

        
    if(amt_1/balanceAmt > _rebalance):  
        amtRe =(amt_1-amt2Convert)/2 #amtRe amt_1
        if(amtRe > 20):
            res = bitkubAPI.placeOrder(_symbol,'sell', amtRe, rateAsk, 'market')
            if('error' not in res):
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f"buy {_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}")
                mongo.lineMsg(f" buy {_symbol} {res['amt']} {symbol_2} at { res['rat']}  \r\n  totalAmt:{round(totalAmt, 2)}") 
                mongo.save({  'position':'sell',
                                        'symbol':_symbol,
                                        'amt':res['amt'],
                                        'rat':res['rat'],
                                        'total':round(totalAmt, 2),
                                        'time':res['rat']})
            else:
                print(res)
84/20:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    symbol_1  = _symbolSplit[0]
    symbol_2   = _symbolSplit[1]
    sym2Convert = _symbolSplit[1]+"convert"

    amt_1 = bitkubAPI.balance()[symbol_1]['available']
    amt_2 = bitkubAPI.balance()[symbol_2]['available']
    amt2Convert = amt_2*rateAsk
            
    #reblanceCondition
    totalAmt =amt_1+ amt2Convert
    balanceAmt = totalAmt/2
    print(f'{symbol_1}:{round(amt_1, 2)} {symbol_2}:{round(amt_2, 2)} totalAmt:{round(totalAmt, 2)}   {datetime.datetime.fromtimestamp(tsAsk)}')
 
    if(amt2Convert/balanceAmt > _rebalance):  
        amtRe =(amt2Convert-amt_1)/2 #amtRe amt_1
        if(amtRe > 20):
            amtRe = amtRe/rateAsk         #amtRe Convert 
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            print(_symbol)
            res={  'position':'buy','symbol':'_symbol', 'amt':2,  'rat':1,'rec':}
            if('error' not in res):
                
                tsOrder = 0#datetime.datetime.fromtimestamp(res['ts'])
                print(f"buy {_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}")
                mongo.lineMsg(f" buy {_symbol} {res['amt']} {symbol_2} at { res['rat']}  \r\n  totalAmt:{round(totalAmt, 2)}") 
                mongo.save({  'position':'buy',
                                        'symbol':_symbol,
                                        'amt':res['amt'],
                                        'rat':res['rat'],
                                        'total':round(totalAmt, 2),
                                        'time':tsOrder})
            else:
                print(res)

        
    if(amt_1/balanceAmt > _rebalance):  
        amtRe =(amt_1-amt2Convert)/2 #amtRe amt_1
        if(amtRe > 20):
            res = bitkubAPI.placeOrder(_symbol,'sell', amtRe, rateAsk, 'market')
            if('error' not in res):
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f"buy {_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}")
                mongo.lineMsg(f" buy {_symbol} {res['amt']} {symbol_2} at { res['rat']}  \r\n  totalAmt:{round(totalAmt, 2)}") 
                mongo.save({  'position':'sell',
                                        'symbol':_symbol,
                                        'amt':res['amt'],
                                        'rat':res['rat'],
                                        'total':round(totalAmt, 2),
                                        'time':res['rat']})
            else:
                print(res)
84/21:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    symbol_1  = _symbolSplit[0]
    symbol_2   = _symbolSplit[1]
    sym2Convert = _symbolSplit[1]+"convert"

    amt_1 = bitkubAPI.balance()[symbol_1]['available']
    amt_2 = bitkubAPI.balance()[symbol_2]['available']
    amt2Convert = amt_2*rateAsk
            
    #reblanceCondition
    totalAmt =amt_1+ amt2Convert
    balanceAmt = totalAmt/2
    print(f'{symbol_1}:{round(amt_1, 2)} {symbol_2}:{round(amt_2, 2)} totalAmt:{round(totalAmt, 2)}   {datetime.datetime.fromtimestamp(tsAsk)}')
 
    if(amt2Convert/balanceAmt > _rebalance):  
        amtRe =(amt2Convert-amt_1)/2 #amtRe amt_1
        if(amtRe > 20):
            amtRe = amtRe/rateAsk         #amtRe Convert 
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            print(_symbol)
            res={  'position':'buy','symbol':'1234', 'amt':2,  'rat':1,'rec':}
            if('error' not in res):
                
                tsOrder = 0#datetime.datetime.fromtimestamp(res['ts'])
                print(f"buy {_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}")
                mongo.lineMsg(f" buy {_symbol} {res['amt']} {symbol_2} at { res['rat']}  \r\n  totalAmt:{round(totalAmt, 2)}") 
                mongo.save({  'position':'buy',
                                        'symbol':_symbol,
                                        'amt':res['amt'],
                                        'rat':res['rat'],
                                        'total':round(totalAmt, 2),
                                        'time':tsOrder})
            else:
                print(res)

        
    if(amt_1/balanceAmt > _rebalance):  
        amtRe =(amt_1-amt2Convert)/2 #amtRe amt_1
        if(amtRe > 20):
            res = bitkubAPI.placeOrder(_symbol,'sell', amtRe, rateAsk, 'market')
            if('error' not in res):
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f"buy {_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}")
                mongo.lineMsg(f" buy {_symbol} {res['amt']} {symbol_2} at { res['rat']}  \r\n  totalAmt:{round(totalAmt, 2)}") 
                mongo.save({  'position':'sell',
                                        'symbol':_symbol,
                                        'amt':res['amt'],
                                        'rat':res['rat'],
                                        'total':round(totalAmt, 2),
                                        'time':res['rat']})
            else:
                print(res)
84/22:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    symbol_1  = _symbolSplit[0]
    symbol_2   = _symbolSplit[1]
    sym2Convert = _symbolSplit[1]+"convert"

    amt_1 = bitkubAPI.balance()[symbol_1]['available']
    amt_2 = bitkubAPI.balance()[symbol_2]['available']
    amt2Convert = amt_2*rateAsk
            
    #reblanceCondition
    totalAmt =amt_1+ amt2Convert
    balanceAmt = totalAmt/2
    print(f'{symbol_1}:{round(amt_1, 2)} {symbol_2}:{round(amt_2, 2)} totalAmt:{round(totalAmt, 2)}   {datetime.datetime.fromtimestamp(tsAsk)}')
 
    if(amt2Convert/balanceAmt > _rebalance):  
        amtRe =(amt2Convert-amt_1)/2 #amtRe amt_1
        if(amtRe > 20):
            amtRe = amtRe/rateAsk         #amtRe Convert 
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            print(_symbol)
            res={  'rat':1,'rec':}
            if('error' not in res):
                
                tsOrder = 0#datetime.datetime.fromtimestamp(res['ts'])
                print(f"buy {_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}")
                mongo.lineMsg(f" buy {_symbol} {res['amt']} {symbol_2} at { res['rat']}  \r\n  totalAmt:{round(totalAmt, 2)}") 
                mongo.save({  'position':'buy',
                                        'symbol':_symbol,
                                        'amt':res['amt'],
                                        'rat':res['rat'],
                                        'total':round(totalAmt, 2),
                                        'time':tsOrder})
            else:
                print(res)

        
    if(amt_1/balanceAmt > _rebalance):  
        amtRe =(amt_1-amt2Convert)/2 #amtRe amt_1
        if(amtRe > 20):
            res = bitkubAPI.placeOrder(_symbol,'sell', amtRe, rateAsk, 'market')
            if('error' not in res):
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f"buy {_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}")
                mongo.lineMsg(f" buy {_symbol} {res['amt']} {symbol_2} at { res['rat']}  \r\n  totalAmt:{round(totalAmt, 2)}") 
                mongo.save({  'position':'sell',
                                        'symbol':_symbol,
                                        'amt':res['amt'],
                                        'rat':res['rat'],
                                        'total':round(totalAmt, 2),
                                        'time':res['rat']})
            else:
                print(res)
84/23:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    symbol_1  = _symbolSplit[0]
    symbol_2   = _symbolSplit[1]
    sym2Convert = _symbolSplit[1]+"convert"

    amt_1 = bitkubAPI.balance()[symbol_1]['available']
    amt_2 = bitkubAPI.balance()[symbol_2]['available']
    amt2Convert = amt_2*rateAsk
            
    #reblanceCondition
    totalAmt =amt_1+ amt2Convert
    balanceAmt = totalAmt/2
    print(f'{symbol_1}:{round(amt_1, 2)} {symbol_2}:{round(amt_2, 2)} totalAmt:{round(totalAmt, 2)}   {datetime.datetime.fromtimestamp(tsAsk)}')
 
    if(amt2Convert/balanceAmt > _rebalance):  
        amtRe =(amt2Convert-amt_1)/2 #amtRe amt_1
        if(amtRe > 20):
            amtRe = amtRe/rateAsk         #amtRe Convert 
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            print(_symbol)
            res={  'position':'buy','symbol':_symbol, 'amt':2,  'rat':1,'rec':3}
            if('error' not in res):
                
                tsOrder = 0#datetime.datetime.fromtimestamp(res['ts'])
                print(f"buy {_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}")
                mongo.lineMsg(f" buy {_symbol} {res['amt']} {symbol_2} at { res['rat']}  \r\n  totalAmt:{round(totalAmt, 2)}") 
                mongo.save({  'position':'buy',
                                        'symbol':_symbol,
                                        'amt':res['amt'],
                                        'rat':res['rat'],
                                        'total':round(totalAmt, 2),
                                        'time':tsOrder})
            else:
                print(res)

        
    if(amt_1/balanceAmt > _rebalance):  
        amtRe =(amt_1-amt2Convert)/2 #amtRe amt_1
        if(amtRe > 20):
            res = bitkubAPI.placeOrder(_symbol,'sell', amtRe, rateAsk, 'market')
            if('error' not in res):
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f"buy {_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}")
                mongo.lineMsg(f" buy {_symbol} {res['amt']} {symbol_2} at { res['rat']}  \r\n  totalAmt:{round(totalAmt, 2)}") 
                mongo.save({  'position':'sell',
                                        'symbol':_symbol,
                                        'amt':res['amt'],
                                        'rat':res['rat'],
                                        'total':round(totalAmt, 2),
                                        'time':res['rat']})
            else:
                print(res)
84/24:
initialization()
main()
84/25:
import datetime
from datetime import datetime as dt
import numpy as np
from BitkubTrade import Bitkub
from mongoDB import mongoDatabase
import time 
# API info
API_HOST = 'https://api.bitkub.com'
API_KEY = '343f340ba1aafd4a4d056801c791f14d'
API_SECRET = b'4fd33427a5d4dfddb93ce38251c4d8e5'
84/26:
# database info
mongo = mongoDatabase(
    database='trading_db'
    ,collection= 'bitkubRebalance'
    ,mongodb_srv="mongodb+srv://wasan:1234@cluster0.ujivx.gcp.mongodb.net/trading_db?retryWrites=true&w=majority"
    ,line_token='QHQPbxDrgD35meR5LDh0PniRVDGYUBNrH8ls42ThiKM'
    )
85/1:
# API info
API_HOST = 'https://api.bitkub.com'
API_KEY = '343f340ba1aafd4a4d056801c791f14d'
API_SECRET = b'4fd33427a5d4dfddb93ce38251c4d8e5'

# database info
mongo = database(
    database='trading_db'
    ,collection= 'bitkubRebalance'
    ,mongodb_srv="mongodb+srv://wasan:1234@cluster0.ujivx.gcp.mongodb.net/trading_db?retryWrites=true&w=majority"
    ,line_token='QHQPbxDrgD35meR5LDh0PniRVDGYUBNrH8ls42ThiKM'
    )
85/2:
import datetime
from datetime import datetime as dt
import numpy as np
from BitkubTrade import Bitkub
from mongoDB import database
import time
85/3:
# API info
API_HOST = 'https://api.bitkub.com'
API_KEY = '343f340ba1aafd4a4d056801c791f14d'
API_SECRET = b'4fd33427a5d4dfddb93ce38251c4d8e5'

# database info
mongo = database(
    database='trading_db'
    ,collection= 'bitkubRebalance'
    ,mongodb_srv="mongodb+srv://wasan:1234@cluster0.ujivx.gcp.mongodb.net/trading_db?retryWrites=true&w=majority"
    ,line_token='QHQPbxDrgD35meR5LDh0PniRVDGYUBNrH8ls42ThiKM'
    )
85/4:
def initialization():  
    print("----------- Initialize -----------")
    #--------------------------variable-----------------------------
    #ProductSetting
    global _symbol, _symbolSplit ,_rebalance
    _symbol = 'THB_XRP'  # THB_XRP
    _symbolSplit =  _symbol.split("_")
    _rebalance = 0.10#0.1 = 10% min 20 THB
    #SystemSetting
    global _system
    _system = True

    #API
    global bitkubAPI
    bitkubAPI=Bitkub(API_HOST,API_KEY,API_SECRET)
85/5:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    symbol_1  = _symbolSplit[0]
    symbol_2   = _symbolSplit[1]
    sym2Convert = _symbolSplit[1]+"convert"

    amt_1 = bitkubAPI.balance()[symbol_1]['available']
    amt_2 = bitkubAPI.balance()[symbol_2]['available']
    amt2Convert = amt_2*rateAsk
            
    #reblanceCondition
    totalAmt =amt_1+ amt2Convert
    balanceAmt = totalAmt/2
    print(f'{symbol_1}:{round(amt_1, 2)} {symbol_2}:{round(amt_2, 2)} totalAmt:{round(totalAmt, 2)}   {datetime.datetime.fromtimestamp(tsAsk)}')
 
    if(amt2Convert/balanceAmt > _rebalance):  
        amtRe =(amt2Convert-amt_1)/2 #amtRe amt_1
        if(amtRe > 20):
            amtRe = amtRe/rateAsk         #amtRe Convert 
            #res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            print(_symbol)
            res={  'position':'buy','symbol':_symbol, 'amt':2,  'rat':1,'rec':3}
            if('error' not in res):
                
                tsOrder = 0#datetime.datetime.fromtimestamp(res['ts'])
                print(f"buy {_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}")
                mongo.lineMsg(f" buy {_symbol} {res['amt']} {symbol_2} at { res['rat']}  \r\n  totalAmt:{round(totalAmt, 2)}") 
                mongo.save({  'position':'buy',
                                        'symbol':_symbol,
                                        'amt':res['amt'],
                                        'rat':res['rat'],
                                        'total':round(totalAmt, 2),
                                        'time':tsOrder})
            else:
                print(res)

        
    if(amt_1/balanceAmt > _rebalance):  
        amtRe =(amt_1-amt2Convert)/2 #amtRe amt_1
        if(amtRe > 20):
            res = bitkubAPI.placeOrder(_symbol,'sell', amtRe, rateAsk, 'market')
            if('error' not in res):
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f"buy {_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}")
                mongo.lineMsg(f" buy {_symbol} {res['amt']} {symbol_2} at { res['rat']}  \r\n  totalAmt:{round(totalAmt, 2)}") 
                mongo.save({  'position':'sell',
                                        'symbol':_symbol,
                                        'amt':res['amt'],
                                        'rat':res['rat'],
                                        'total':round(totalAmt, 2),
                                        'time':res['rat']})
            else:
                print(res)
85/6:
initialization()
main()
85/7: 100*0.05
85/8: 100*0.10
85/9: 100*0.20
85/10: 200*0.20
85/11: 200*0.10
85/12: 100*2.718
85/13: 200*2.718
86/1:
import datetime
from datetime import datetime as dt
import numpy as np
from BitkubTrade import Bitkub
from mongoDB import database
import time
86/2:
import datetime
from datetime import datetime as dt
import numpy as np
from BitkubTrade import Bitkub
from mongoDB import database
import time
86/3:
# API info
API_HOST = 'https://api.bitkub.com'
API_KEY = '343f340ba1aafd4a4d056801c791f14d'
API_SECRET = b'4fd33427a5d4dfddb93ce38251c4d8e5'

# database info
mongo = database(
    database='trading_db'
    ,collection= 'bitkubRebalance'
    ,mongodb_srv="mongodb+srv://wasan:1234@cluster0.ujivx.gcp.mongodb.net/trading_db?retryWrites=true&w=majority"
    ,line_token='QHQPbxDrgD35meR5LDh0PniRVDGYUBNrH8ls42ThiKM'
    )
86/4:
def initialization():  
    print("----------- Initialize -----------")
    #--------------------------variable-----------------------------
    #ProductSetting
    global _symbol, _symbolSplit ,_rebalance
    _symbol = 'THB_XRP'  # THB_XRP
    _symbolSplit =  _symbol.split("_")
    _rebalance = 0.20 #0.1 = 10% min 20 THB
    #SystemSetting
    global _system
    _system = True

    #API
    global bitkubAPI
    bitkubAPI=Bitkub(API_HOST,API_KEY,API_SECRET)
86/5:
#//////////////////////////////////////////////////////////////////////
def main(): 
    print("-------------- Start --------------")
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    symbol_1  = _symbolSplit[0]
    symbol_2   = _symbolSplit[1]
    sym2Convert = _symbolSplit[1]+"convert"

    amt_1 = bitkubAPI.balance()[symbol_1]['available']
    amt_2 = bitkubAPI.balance()[symbol_2]['available']
    amt2Convert = amt_2*rateAsk
            
    #reblanceCondition
    totalAmt =amt_1+ amt2Convert
    balanceAmt = totalAmt/2
    print(f'{symbol_1}:{round(amt_1, 2)} {symbol_2}:{round(amt_2, 2)} totalAmt:{round(totalAmt, 2)}   {datetime.datetime.fromtimestamp(tsAsk)}')
 
    if(amt2Convert/balanceAmt > _rebalance):  
        amtRe =(amt2Convert-amt_1)/2 #amtRe amt_1
        if(amtRe > 20):
            amtRe = amtRe/rateAsk         #amtRe Convert 
            res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            if('error' not in res):
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f"Buy {_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}")
                mongo.lineMsg(f" Buy {_symbol} {res['amt']} {symbol_2} at { res['rat']}  \r\n  total:{round(totalAmt, 2)}") 
                mongo.save({'position':'buy',
                                    'symbol':_symbol,
                                    'amt':res['amt'],
                                    'rat':res['rat'],
                                    'total':round(totalAmt, 2),
                                    'time':tsOrder})
            else:
                print(res)

        
    if(amt_1/balanceAmt > _rebalance):  
        amtRe =(amt_1-amt2Convert)/2 #amtRe amt_1
        if(amtRe > 20):
            res = bitkubAPI.placeOrder(_symbol,'sell', amtRe, rateAsk, 'market')
            if('error' not in res):
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f"Sell {_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}")
                mongo.lineMsg(f" Sell {_symbol} {res['amt']} {symbol_2} at { res['rat']}  \r\n  total:{round(totalAmt, 2)}") 
                mongo.save({'position':'sell',
                                    'symbol':_symbol,
                                    'amt':res['amt'],
                                    'rat':res['rat'],
                                    'total':round(totalAmt, 2),
                                    'time':tsOrder})
            else:
                print(res)
86/6:
initialization()
while(_system):
    main()
    time.sleep(1)
86/7:
def initialization():  
    print("----------- Initialize -----------")
    #--------------------------variable-----------------------------
    #ProductSetting
    global _symbol, _symbolSplit ,_rebalance
    _symbol = 'THB_XRP'  # THB_XRP
    _symbolSplit =  _symbol.split("_")
    _rebalance = 0.20 #0.1 = 10% min 20 THB
    #SystemSetting
    global _system
    _system = True

    #API
    global bitkubAPI
    bitkubAPI=Bitkub(API_HOST,API_KEY,API_SECRET)
    print("------------ Start ------------")
86/8:
#//////////////////////////////////////////////////////////////////////
def main(): 
    #-----ASK-----
    Ask = bitkubAPI.asks(_symbol)[0]
    tsAsk   = Ask[1]
    volAsk  = Ask[2]
    amtAsk  = Ask[4]
    rateAsk = Ask[3]
    #-----BID-----
    Bid = bitkubAPI.bids(_symbol)[0]
    tsBid   = Bid[1]
    volBid  = Bid[2]
    amtBid  = Bid[4]
    rateBid = Bid[3]

    #-----balance-----
    symbol_1  = _symbolSplit[0]
    symbol_2   = _symbolSplit[1]
    sym2Convert = _symbolSplit[1]+"convert"

    amt_1 = bitkubAPI.balance()[symbol_1]['available']
    amt_2 = bitkubAPI.balance()[symbol_2]['available']
    amt2Convert = amt_2*rateAsk
            
    #reblanceCondition
    totalAmt =amt_1+ amt2Convert
    balanceAmt = totalAmt/2
    print(f'{symbol_1}:{round(amt_1, 2)} {symbol_2}:{round(amt_2, 2)} totalAmt:{round(totalAmt, 2)}   {datetime.datetime.fromtimestamp(tsAsk)}',end="")
 
    if(amt2Convert/balanceAmt > _rebalance):  
        amtRe =(amt2Convert-amt_1)/2 #amtRe amt_1
        if(amtRe > 20):
            amtRe = amtRe/rateAsk         #amtRe Convert 
            res = bitkubAPI.placeOrder(_symbol,'buy', amtRe, rateAsk, 'market')
            if('error' not in res):
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f"Buy {_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}",end="")
                print('')
                mongo.lineMsg(f" Buy {_symbol} {res['amt']} {symbol_2} at { res['rat']}  \r\n  total:{round(totalAmt, 2)}") 
                mongo.save({'position':'buy',
                                    'symbol':_symbol,
                                    'amt':res['amt'],
                                    'rat':res['rat'],
                                    'total':round(totalAmt, 2),
                                    'time':tsOrder})
            else:
                print(res)

        
    if(amt_1/balanceAmt > _rebalance):  
        amtRe =(amt_1-amt2Convert)/2 #amtRe amt_1
        if(amtRe > 20):
            res = bitkubAPI.placeOrder(_symbol,'sell', amtRe, rateAsk, 'market')
            if('error' not in res):
                tsOrder = datetime.datetime.fromtimestamp(res['ts'])
                print(f"Sell {_symbol} {res['amt']} at{ res['rat']} {res['rec']}   {tsOrder}",end="")
                print('')
                mongo.lineMsg(f" Sell {_symbol} {res['amt']} {symbol_2} at { res['rat']}  \r\n  total:{round(totalAmt, 2)}") 
                mongo.save({'position':'sell',
                                    'symbol':_symbol,
                                    'amt':res['amt'],
                                    'rat':res['rat'],
                                    'total':round(totalAmt, 2),
                                    'time':tsOrder})
            else:
                print(res)
86/9:
initialization()
while(_system):
    main()
    time.sleep(1)
   1: %history -g -f anyfilename
